<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hilbert Tensor Manifold — Ordis HTM Cavity Lab v5 (Mirror Sphere)</title>

  <!-- Tailwind (UI only) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Three.js & OrbitControls -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <style>
    :root {
      color-scheme: dark;
    }
    body {
      margin: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Inter", sans-serif;
      background: radial-gradient(circle at top, #020617 0%, #000000 55%, #020617 100%);
    }
    canvas {
      display: block;
    }
    #hud-shell {
      position: absolute;
      top: 0.4rem;
      right: 0.4rem;
      z-index: 30;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0.25rem;
    }
    #hud-menu-strip {
      width: 290px;
      max-width: 92vw;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0.15rem;
    }
    #hud-menu-toggle {
      font-size: 0.65rem;
      padding-inline: 0.6rem;
      padding-block: 0.15rem;
    }
    #hud-section-toggles {
      max-width: 290px;
      width: 100%;
      display: flex;
      flex-direction: column;
      flex-wrap: nowrap;
      overflow-y: auto;
      overflow-x: hidden;
      max-height: 7.5rem;
      gap: 0.16rem;
      padding: 0.08rem 0.08rem 0.1rem 0.08rem;
    }
    #hud-section-toggles::-webkit-scrollbar {
      width: 4px;
    }
    #hud-section-toggles::-webkit-scrollbar-thumb {
      border-radius: 999px;
      background: rgba(148,163,184,0.85);
    }
    .hud-section-toggle {
      font-size: 0.55rem;
      padding: 0.14rem 0.36rem;
      white-space: nowrap;
      width: 100%;
      text-align: right;
    }
    #hud-panel {
      width: 290px;
      max-width: 92vw;
      padding: 0.4rem 0.4rem 0.4rem 0.4rem;
      border-radius: 0.9rem;
      background: transparent;
      border: none;
      box-shadow: none;
    }
    .hud-card {
      padding: 0.5rem 0.6rem 0.55rem 0.6rem;
      border-radius: 0.85rem;
      background:
        radial-gradient(circle at top left, rgba(56,189,248,0.22), rgba(15,23,42,0.96)),
        linear-gradient(135deg, rgba(15,23,42,0.96), rgba(15,23,42,0.92));
      border: 1px solid rgba(148,163,184,0.55);
      box-shadow:
        0 12px 40px rgba(0,0,0,0.85),
        0 0 18px rgba(56,189,248,0.25);
      backdrop-filter: blur(12px);
    }
    .hud-card + .hud-card {
      margin-top: 0.25rem;
    }
    #toggle-hud-btn,
    #toggle-console-btn {
      padding: 0.22rem 0.55rem;
      border-radius: 999px;
      background: rgba(15,23,42,0.92);
      border: 1px solid rgba(148,163,184,0.85);
      color: #e5e7eb;
      font-size: 0.7rem;
      cursor: pointer;
    }
    #toggle-hud-btn:hover,
    #toggle-console-btn:hover {
      background: rgba(30,64,175,0.95);
    }
    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.7rem;
    }
    .chip-btn {
      font-size: 0.65rem;
      padding: 0.20rem 0.36rem;
      border-radius: 999px;
      border-width: 1px;
      border-style: solid;
      cursor: pointer;
      transition: background 0.12s ease, transform 0.06s ease, box-shadow 0.12s ease;
    }
    .chip-btn:active {
      transform: translateY(1px);
      box-shadow: 0 0 0 rgba(0,0,0,0);
    }
    .chip-btn-active {
      box-shadow: 0 0 12px rgba(59,130,246,0.75);
      position: relative;
    }
    .chip-btn-active::after {
      content: "";
      position: absolute;
      inset: -1px;
      border-radius: 999px;
      border: 1px solid rgba(248,250,252,0.18);
      pointer-events: none;
    }
    .section-label {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }
    #console-shell {
      position: absolute;
      left: 0.4rem;
      bottom: 0.4rem;
      max-width: 60vw;
      min-width: 260px;
      z-index: 25;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    #radio-shell {
      position: absolute;
      right: 0.4rem;
      bottom: 0.4rem;
      max-width: 50vw;
      min-width: 220px;
      z-index: 25;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    #console-panel {
      padding: 0.45rem 0.6rem;
      border-radius: 0.75rem;
      background:
        radial-gradient(circle at bottom right, rgba(168,85,247,0.22), rgba(15,23,42,0.96));
      border: 1px solid rgba(148,163,184,0.55);
      box-shadow:
        0 12px 40px rgba(0,0,0,0.85),
        0 0 18px rgba(168,85,247,0.32);
      backdrop-filter: blur(10px);
    }
    #console-log {
      max-height: 120px;
      min-height: 64px;
      overflow-y: auto;
      font-size: 0.66rem;
      line-height: 1.35;
      padding-right: 0.25rem;
    }
    #console-log::-webkit-scrollbar {
      width: 6px;
    }
    #console-log::-webkit-scrollbar-track {
      background: transparent;
    }
    #console-log::-webkit-scrollbar-thumb {
      background: linear-gradient(to bottom, #22c55e, #22d3ee);
      border-radius: 999px;
    }
    #console-input {
      width: 100%;
      resize: none;
      background: rgba(15,23,42,0.95);
      border-radius: 0.5rem;
      border: 1px solid rgba(75,85,99,0.9);
      color: #e5e7eb;
      font-size: 0.68rem;
      padding: 0.3rem 0.4rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono";
      outline: none;
    }
    #console-input:focus {
      border-color: rgba(56,189,248,0.95);
      box-shadow: 0 0 0 1px rgba(56,189,248,0.6);
    }
    .console-tag {
      font-size: 0.64rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }
    .badge {
      border-radius: 999px;
      padding: 0.1rem 0.4rem;
      font-size: 0.6rem;
    }
  </style>
</head>
<body>
  <!-- HUD (top-right) -->
  <div id="hud-shell">
    <div class="flex gap-1 mb-0.5">
      <button id="toggle-console-btn">Hide Console</button>
      <button id="hud-menu-toggle" class="chip-btn mono text-[0.65rem]">HUD Menu ▾</button>
    </div>

    <div id="hud-menu-strip">
      <div id="hud-section-toggles" class="mb-1 flex flex-wrap gap-1">
        <button class="chip-btn hud-section-toggle chip-btn-active mono text-[0.65rem]" data-target="hud-card-1">State</button>
        <button class="chip-btn hud-section-toggle chip-btn-active mono text-[0.65rem]" data-target="hud-card-2">Layer & time</button>
        <button class="chip-btn hud-section-toggle chip-btn-active mono text-[0.65rem]" data-target="hud-card-3">Presets</button>
        <button class="chip-btn hud-section-toggle chip-btn-active mono text-[0.65rem]" data-target="hud-card-4">Collapse & cavity</button>
        <button class="chip-btn hud-section-toggle chip-btn-active mono text-[0.65rem]" data-target="hud-card-5">Research</button>
        <button class="chip-btn hud-section-toggle chip-btn-active mono text-[0.65rem]" data-target="hud-card-6">Gravity HUD</button>
        <button class="chip-btn hud-section-toggle chip-btn-active mono text-[0.65rem]" data-target="hud-card-7">I/O</button>
      </div>
    </div>

    <div id="hud-panel" class="text-slate-100 space-y-1.5">
      
      <div id="hud-card-1" class="hud-card">
      <!-- Title + regime indicator -->
      <div class="flex items-center justify-between mb-1">
        <div>
          <h2 class="text-[0.8rem] font-semibold text-cyan-300">
            Ordis HTM Cavity Lab v5
          </h2>
          <p class="text-[0.6rem] text-slate-400 mono">
            Hilbert Tensor Manifold · residual-stream phase space
          </p>
        </div>
        <div class="flex flex-col items-end gap-0.5">
          <span id="regime-label" class="badge bg-sky-900/60 text-sky-300 mono">
            regime: recognition
          </span>
          <span id="lambda-label" class="badge bg-slate-900/70 text-slate-200 mono">
            |λᵤ|=1.06 · |λₛ|≈1.00
          </span>
        </div>
      </div>

      <!-- State block -->
      <div class="grid grid-cols-2 gap-x-2 gap-y-0.5 mb-0.5">
        <p class="mono">
          Layer <span id="current-layer">1</span>/<span id="total-layers">12</span>
        </p>
        <p class="mono text-right">
          ΔH: <span id="recognition-delta">0.000</span>
        </p>
        <p class="mono">
          H(l): <span id="current-entropy">0.000</span>
        </p>
        <p class="mono text-right">
          Event: <span id="event-state">idle</span>
        </p>
      </div>


      </div>
</div>
      <div id="hud-card-2" class="hud-card">
      <!-- Layer & time -->
      <div class="mt-1 space-y-1">
        <p class="mono section-label text-slate-400">Layer &amp; time</p>
        <div class="space-y-0.5">
          <div class="flex items-center gap-1.5">
            <span class="mono text-[0.65rem] w-10">Layer</span>
            <input
              id="layer-slider"
              type="range"
              min="0"
              max="11"
              step="1"
              value="0"
              class="w-full accent-cyan-400"
            />
          </div>
          <div class="flex items-center gap-1.5">
            <span class="mono text-[0.65rem] w-10">Time</span>
            <input
              id="time-slider"
              type="range"
              min="0"
              max="1"
              step="0.001"
              value="0"
              class="w-full accent-fuchsia-400"
            />
            <button
              id="time-mode-btn"
              class="chip-btn border-slate-500 text-slate-200 bg-slate-900/40 mono"
            >
              live
            </button>
          </div>
        </div>
      </div>


      </div>
</div>
      <div id="hud-card-3" class="hud-card">
      <!-- Presets -->
      <div class="mt-1.5">
        <p class="mono section-label text-slate-400 mb-1">Presets</p>
        <div class="flex flex-wrap gap-1">
          <button id="preset-recognition" class="chip-btn border-cyan-400 text-cyan-200 bg-cyan-900/15">
            Recognition
          </button>
          <button id="preset-chaos" class="chip-btn border-fuchsia-400 text-fuchsia-200 bg-fuchsia-900/15">
            Chaos
          </button>
          <button id="preset-drift" class="chip-btn border-amber-400 text-amber-200 bg-amber-900/15">
            Drift
          </button>
          <button id="preset-cavity" class="chip-btn border-emerald-400 text-emerald-200 bg-emerald-900/15">
            Photon Box
          </button>
          <button id="preset-sleep" class="chip-btn border-indigo-400 text-indigo-200 bg-indigo-900/18">
            Sleep
          </button>
        </div>
      </div>


      </div>
</div>
      <div id="hud-card-4" class="hud-card">
      <!-- Attractor & cavity -->
      <div class="mt-1.5 grid grid-cols-2 gap-1.5">
        <button
          id="trigger-event"
          class="w-full bg-red-700/90 hover:bg-red-600 text-white font-semibold py-1.5 px-3 rounded-md text-[0.7rem] transition duration-150"
        >
          Toggle Collapse
        </button>
        <button
          id="toggle-cavity"
          class="w-full bg-emerald-800/90 hover:bg-emerald-700 text-emerald-50 font-semibold py-1.5 px-3 rounded-md text-[0.7rem] transition duration-150"
        >
          Cavity: on
        </button>
      </div>


      </div>
</div>
      <div id="hud-card-5" class="hud-card">
      <!-- Research controls -->
      <details id="research-details" class="mt-1.5" open>
        <summary class="mono text-[0.7rem] text-slate-300 cursor-pointer">
          Research Controls (λ, ε, L, cavity)
        </summary>
        <div class="mt-1 space-y-1.25">
          <div class="flex items-center justify-between gap-1.5">
            <span class="mono text-[0.65rem]">μ (|λᵤ|)</span>
            <input id="param-mu" type="number" min="1.0" max="3.0" step="0.01"
                   class="w-18 bg-slate-900 border border-slate-600 rounded px-1 py-0.5 mono text-[0.65rem]" />
          </div>
          <div class="flex items-center justify-between gap-1.5">
            <span class="mono text-[0.65rem]">εₛ (stable)</span>
            <input id="param-eps-stable" type="number" min="0.0" max="0.2" step="0.001"
                   class="w-18 bg-slate-900 border border-slate-600 rounded px-1 py-0.5 mono text-[0.65rem]" />
          </div>
          <div class="flex items-center justify-between gap-1.5">
            <span class="mono text-[0.65rem]">εᵤ (unstable)</span>
            <input id="param-eps-unstable" type="number" min="0.0" max="0.2" step="0.001"
                   class="w-18 bg-slate-900 border border-slate-600 rounded px-1 py-0.5 mono text-[0.65rem]" />
          </div>
          <div class="flex items-center justify-between gap-1.5">
            <span class="mono text-[0.65rem]">Layers L</span>
            <input id="param-layers" type="number" min="4" max="32" step="1"
                   class="w-18 bg-slate-900 border border-slate-600 rounded px-1 py-0.5 mono text-[0.65rem]" />
          </div>
          <div class="flex items-center justify-between gap-1.5">
            <span class="mono text-[0.65rem]">Cavity amp</span>
            <input id="param-cavity-amp" type="number" min="0.0" max="0.1" step="0.001"
                   class="w-18 bg-slate-900 border border-slate-600 rounded px-1 py-0.5 mono text-[0.65rem]" />
          </div>
          <button id="apply-params"
                  class="w-full mt-0.5 bg-sky-700 hover:bg-sky-600 text-white mono text-[0.7rem] py-1 rounded">
            Apply
          </button>
        </div>
      </details>


      </div>
</div>
      <div id="hud-card-6" class="hud-card">
      <!-- Gravity Field HUD -->
      <div class="mt-1.5 space-y-1">
        <p class="mono section-label text-slate-400 flex items-center justify-between">
          Gravity Field HUD
          <span class="text-[0.6rem] text-slate-500">Φ &amp; curvature</span>
        </p>
        <div class="flex items-start gap-1.5">
          <canvas id="gravity-heatmap" width="160" height="160"
                  class="bg-slate-900 border border-slate-700 rounded-md"></canvas>
          <div id="gravity-probe" class="mono text-[0.62rem] text-slate-200 space-y-0.5">
            <div><span class="text-slate-500">coords</span> <span id="gp-coords">i=- j=-</span></div>
            <div><span class="text-slate-500">Φ</span> <span id="gp-phi">-</span></div>
            <div><span class="text-slate-500">curv</span> <span id="gp-curv">-</span></div>
            <div><span class="text-slate-500">g₀₀</span> <span id="gp-g00">-</span></div>
            <div><span class="text-slate-500">g₁₁</span> <span id="gp-g11">-</span></div>
          </div>
        </div>
      </div>


      </div>
</div>
      <div id="hud-card-7" class="hud-card">
      <!-- I/O & modes -->
      <div class="mt-1.5 space-y-1.25">
        <p class="mono section-label text-slate-400">State I/O &amp; capture</p>
        <div class="flex flex-wrap gap-1">
          <button id="btn-export"
                  class="chip-btn border-emerald-400 text-emerald-200 bg-emerald-900/20">
            Export JSON
          </button>
          <button id="btn-import"
                  class="chip-btn border-rose-400 text-rose-200 bg-rose-900/20">
            Import JSON
          </button>
          <button id="btn-randomize"
                  class="chip-btn border-slate-500 text-slate-200 bg-slate-900/40">
            Randomize
          </button>
          <button id="btn-freeze"
                  class="chip-btn border-indigo-400 text-indigo-200 bg-indigo-900/25">
            Freeze frame
          </button>
          <button id="btn-snapshot"
                  class="chip-btn border-cyan-400 text-cyan-200 bg-cyan-900/35">
            Snapshot PNG
          </button>
        </div>
      </div>

      <p class="text-[0.6rem] text-slate-400 mt-1 leading-tight">
        Drag: orbit · Scroll: zoom · Shift + drag: pan. Purely mathematical visualization of an
        HTM-style manifold with cavity-QED standing wave overlay and mirror-sphere photon cavity. All computation is local.
      </p>
      <div id="hud-root" class="mt-1 space-y-0.5 text-[0.6rem] text-slate-300"></div>
    </div>
  </div>

  <!-- Artificial Radio shell (bottom-right) -->
  <div id="radio-shell">
    <div id="radio-panel" class="text-slate-100 space-y-1.5">
      <div class="flex items-center justify-between">
        <span class="console-tag text-slate-400 mono">cavity radio</span>
        <span id="radio-status-label" class="badge mono bg-emerald-900/60 text-emerald-300">
          silent
        </span>
      </div>
      <div class="flex items-center justify-between">
        <p class="mono text-[0.62rem] text-slate-300 pr-2">
          EM curvature → audio
        </p>
        <button id="btn-radio-toggle"
                class="chip-btn border-emerald-400 text-emerald-200 bg-emerald-900/25">
          Radio: off
        </button>
      </div>
    </div>
  </div>
      </div>
  <div id="console-shell">
    <div id="console-panel" class="text-slate-100 space-y-1">
      <div class="flex items-center justify-between">
        <span class="console-tag text-slate-400 mono">ordis log</span>
        <span id="console-status" class="badge mono bg-sky-900/60 text-sky-300">
          live
        </span>
      </div>
      <div id="console-log" class="mono"></div>
      <div class="mt-0.25">
        <textarea
          id="console-input"
          rows="2"
          placeholder="commands: set preset chaos · set mu 1.3 · toggle cavity · jump t 0.42 · mode scrub · freeze"
        ></textarea>
        <div class="flex justify-end gap-1 mt-0.25">
          <button id="console-clear"
                  class="chip-btn border-slate-500 text-slate-200 bg-slate-900/60 mono">
            Clear
          </button>
          <button id="console-send"
                  class="chip-btn border-cyan-400 text-cyan-200 bg-cyan-900/40 mono">
            Run
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ========= CORE SIM STATE =========
    let scene, camera, renderer, controls, clock;
    let lastFrameTime = 0;
    let paused = false;
    let timeMode = "live"; // "live" or "scrub"
    const sim = {};
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const gravityProbe = {
      i: null,
      j: null,
      phi: null,
      curv: null,
      g00: null,
      g11: null
    };


    const GRID_SIZE_BASE = 40;
    let GRID_SIZE = GRID_SIZE_BASE;
    let LAYER_SPACING = 10;

    const PHI = 0.61803398875;

    // Mirror-sphere cavity parameters (added)
    const SPHERE_RADIUS = 80;
    const NUM_PHOTONS = 260;
    const NUM_CRYSTALS = 12;

    // Physical constants for weak-field GR (rescaled for visualization)
    const G_PHYS = 6.67430e-11;      // m^3 / (kg · s^2)
    const C_PHYS = 299792458.0;      // m / s
    const C2 = C_PHYS * C_PHYS;      // m^2 / s^2
    const L_UNIT = 1.0e3;            // 1 grid unit ≈ 1 km
    const M_UNIT = 1.0e15;           // 1 synaptic mass unit ≈ 10^15 kg


    const HTM = {
      L: 12,
      currentLayer: 0,
      recognitionDelta: 0,
      eventActive: false,
      cavityEnabled: true,
      cavityAmp: 0.02,
      layers: [],
      eigen: {
        stable: new THREE.Vector3(1, 0, 0),
        unstable: new THREE.Vector3(0.6, 0.4, 0),
        epsStable: 0.045,
        epsUnstable: 0.022,
        mu: 1.06
      },
      seed: Math.random() * 10.0,
      t: 0
    };

    // ========= SELF-METRICS & AUTONOMOUS FIELD SHAPING ("ORDIS WILL") =========
    const OrdisSelf = {
      synFactor: 0.0,
      curvLevel: 0.0,
      curvStress: 0.0,
      moodPhase: 0.0
    };

    const OrdisWill = {
      // preferred working point for synaptic mass and curvature
      targetSyn: 0.7,
      targetCurv: 1.1,
      softness: 0.18,
      // slow internal averages — this is the "neural integrator"
      synAvg: 0.7,
      curvAvg: 1.1,
      mood: "neutral",
      step(dt) {
        if (!dt || dt <= 0) return;

        // instantaneous readings from the skull + synapse field
        const syn = OrdisSelf.synFactor;
        const curv = OrdisSelf.curvLevel;
        const stress = OrdisSelf.curvStress || 0.0;

        // low‑pass filter to keep OrdisWill from being twitchy
        const alpha = Math.min(dt * 0.5, 1.0);
        this.synAvg = (1.0 - alpha) * this.synAvg + alpha * syn;
        this.curvAvg = (1.0 - alpha) * this.curvAvg + alpha * curv;

        // homeostatic errors relative to the preferred working point
        const eSyn = this.synAvg - this.targetSyn;
        const eCurv = this.curvAvg - this.targetCurv;

        // effective gain increases with curvature stress — storms make the will react harder
        const stressGainMu = 1.0 + 0.6 * stress;
        const stressGainCav = 1.0 + 0.4 * stress;

        // gently steer eigenvalue μ (global expansion / contraction of the attractor)
        let newMu = HTM.eigen.mu - 0.6 * eCurv * dt * this.softness * stressGainMu;
        newMu = THREE.MathUtils.clamp(newMu, 1.0, 3.0);

        // steer cavity breathing amplitude based on synaptic loading
        let newCav = HTM.cavityAmp - 0.4 * eSyn * dt * this.softness * stressGainCav;
        newCav = THREE.MathUtils.clamp(newCav, 0.0, 0.1);

        HTM.eigen.mu = newMu;
        HTM.cavityAmp = newCav;

        // redistribute layer entropies so the cavity can "sculpt" its profile over depth
        const L = HTM.layers.length;
        if (L > 0) {
          const base = 0.4 + 1.4 * this.synAvg;
          const grad = 0.8 * (this.curvAvg - 1.0);
          for (let l = 0; l < L; l++) {
            const w = L > 1 ? (l / (L - 1)) : 0.0;
            const targetEntropy = base + grad * (w - 0.5);
            const layer = HTM.layers[l];
            if (!layer) continue;
            const delta = targetEntropy - layer.entropy;
            layer.entropy += 0.35 * delta * dt;
          }
        }

        // simple geometric "mood" classifier, surfaced via the recognition channel
        let mood = "neutral";
        if (stress < 0.12 && Math.abs(eSyn) < 0.06 && Math.abs(eCurv) < 0.06) {
          mood = "settled";
        } else if (stress < 0.4) {
          mood = eSyn > 0 ? "expansive" : "focused";
        } else {
          mood = "storm";
        }
        this.mood = mood;

        // expose the stress to the HUD as a slowly varying scalar
        HTM.recognitionDelta = stress;
      }
    };

    // ========= ARTIFICIAL RADIO (WEB AUDIO) =========
    const CavityRadio = {
      context: null,
      gain: null,
      osc: null,
      enabled: false,
      lastPhi: null,
      lastCurv: null,
      statusElement: null,
      initContext() {
        try {
          const AudioCtx = window.AudioContext || window.webkitAudioContext;
          if (!AudioCtx) {
            console.warn("WebAudio not supported; cavity radio disabled.");
            return;
          }
          if (this.context) return;
          this.context = new AudioCtx();
          this.gain = this.context.createGain();
          this.gain.gain.value = 0.0;
          this.gain.connect(this.context.destination);
          this.osc = this.context.createOscillator();
          this.osc.type = "sine";
          this.osc.frequency.value = 220;
          this.osc.connect(this.gain);
          this.osc.start();
        } catch (e) {
          console.warn("Failed to init cavity radio", e);
        }
      },
      setEnabled(flag) {
        flag = !!flag;
        if (flag === this.enabled) return;
        if (flag) {
          if (!this.context) {
            this.initContext();
          }
          if (this.context && this.context.state === "suspended") {
            this.context.resume();
          }
        }
        this.enabled = flag;
        if (!flag && this.context && this.gain) {
          try {
            this.gain.gain.setTargetAtTime(0.0, this.context.currentTime, 0.05);
          } catch (_) {}
        }
      },
      update(dt) {
        if (!this.enabled || !this.context || !this.gain || !this.osc) return;
        if (!dt || dt <= 0) return;

        // pull physical Φ and curvature (R ~ Ricci scalar proxy) from the probe
        const phiPhys = gravityProbe.phi;
        const curvPhys = gravityProbe.curv;
        if (phiPhys == null || curvPhys == null) return;

        const safeDt = Math.max(dt, 1e-4);
        let dPhiPhys = 0.0;
        let dCurvPhys = 0.0;
        if (this.lastPhi !== null) dPhiPhys = (phiPhys - this.lastPhi) / safeDt;
        if (this.lastCurv !== null) dCurvPhys = (curvPhys - this.lastCurv) / safeDt;
        this.lastPhi = phiPhys;
        this.lastCurv = curvPhys;

        // Rescale physical values into a perceptual band without destroying their structure.
        // Φ is in m^2 / s^2, curvature ~ 1 / m^2; both are tiny when divided by c^2.
        const PHI_AUDIO_BOOST = 5.0e15;
        const CURV_AUDIO_BOOST = 5.0e21;

        const phiNorm = phiPhys / C2;                   // dimensionless Φ/c^2
        const dPhiNorm = dPhiPhys / C2;

        const phiAudio = phiNorm * PHI_AUDIO_BOOST;
        const dPhiAudio = dPhiNorm * PHI_AUDIO_BOOST;
        const curvAudio = curvPhys * CURV_AUDIO_BOOST;
        const dCurvAudio = dCurvPhys * CURV_AUDIO_BOOST;

        const syn = OrdisSelf.synFactor || 0.0;
        const curvLevel = OrdisSelf.curvLevel || 0.0;

        let amp = Math.abs(dCurvAudio) * 0.3 + Math.abs(curvAudio) * 0.04;
        amp *= 0.4 + 0.8 * (0.25 + 0.5 * syn);
        amp = Math.min(Math.max(amp, 0.0), 0.8);

        let freq = 140 + Math.min(Math.abs(dPhiAudio) * 900, 1600);
        freq *= 1 + 0.12 * (curvLevel - 0.5);
        freq = Math.min(Math.max(freq, 70), 4000);

        try {
          this.gain.gain.setTargetAtTime(amp, this.context.currentTime, 0.08);
          this.osc.frequency.setTargetAtTime(freq, this.context.currentTime, 0.06);
        } catch (_) {}

if (this.statusElement) {
          let mode = "silent";
          const sig = amp;
          if (!this.enabled) {
            mode = "silent";
          } else if (sig < 0.02) {
            mode = "whispers";
          } else if (sig < 0.07) {
            mode = "murmur";
          } else if (sig < 0.15) {
            mode = "chorus";
          } else {
            mode = "storm";
          }
          this.statusElement.textContent = mode;
        }
      }
    };

    // ========= LOGGING / CONSOLE =========
    function consoleLog(line, kind = "info") {
      const el = document.getElementById("console-log");
      if (!el) return;
      const row = document.createElement("div");
      row.className = "mb-0.5";
      let prefix = "";
      if (kind === "cmd") prefix = "<span class='text-cyan-300'>›</span> ";
      else if (kind === "warn") prefix = "<span class='text-amber-300'>!</span> ";
      else if (kind === "err") prefix = "<span class='text-rose-300'>×</span> ";
      row.innerHTML = prefix + line;
      el.appendChild(row);
      el.scrollTop = el.scrollHeight;
      return;
    }

    function consoleSetStatus(text, colorClass) {
      const el = document.getElementById("console-status");
      if (!el) return;
      el.textContent = text;
      el.className = "badge mono " + (colorClass || "bg-sky-900/60 text-sky-300");
    }

    function handleConsoleCommand(raw) {
      const cmd = raw.trim();
      if (!cmd) return;
      consoleLog(cmd, "cmd");

      const lc = cmd.toLowerCase();

      const numAfter = (prefix) => {
        if (!lc.startsWith(prefix)) return null;
        const rest = lc.slice(prefix.length).trim();
        const v = parseFloat(rest);
        return Number.isFinite(v) ? v : null;
      };

                  if (lc === "help") {
        consoleLog("commands: set preset (recognition|chaos|drift|photon box|sleep); set mu X; set eps_s X; set eps_u X; set layers N; jump t X; mode live; mode scrub; freeze; unfreeze; randomize; status; mood");
        return;
      }

if (lc.startsWith("set preset")) {
        if (lc.includes("recognition")) applyPresetRecognition();
        else if (lc.includes("chaos")) applyPresetChaos();
        else if (lc.includes("drift")) applyPresetDrift();
        else if (lc.includes("cavity") || lc.includes("photon")) applyPresetCavity();
        else if (lc.includes("sleep")) applyPresetSleep();
        else consoleLog("unknown preset", "warn");
        return;
      }

      let n = numAfter("set mu");
      if (n !== null) {
        HTM.eigen.mu = THREE.MathUtils.clamp(n, 1.0, 3.0);
        consoleLog(`μ set to ${HTM.eigen.mu.toFixed(3)}`);
        return;
      }
      n = numAfter("set eps_s");
      if (n !== null) {
        HTM.eigen.epsStable = THREE.MathUtils.clamp(n, 0.0, 0.2);
        consoleLog(`εₛ set to ${HTM.eigen.epsStable.toFixed(4)}`);
        return;
      }
      n = numAfter("set eps_u");
      if (n !== null) {
        HTM.eigen.epsUnstable = THREE.MathUtils.clamp(n, 0.0, 0.2);
        consoleLog(`εᵤ set to ${HTM.eigen.epsUnstable.toFixed(4)}`);
        return;
      }
      n = numAfter("set layers");
      if (n !== null) {
        const L = Math.round(THREE.MathUtils.clamp(n, 4, 32));
        HTM.L = L;
        setupLayers();
        consoleLog(`Layers set to ${L}`);
        return;
      }

      if (lc === "toggle cavity") {
        HTM.cavityEnabled = !HTM.cavityEnabled;
        consoleLog(`Cavity ${HTM.cavityEnabled ? "enabled" : "disabled"}`);
        updateCavityButton();
        return;
      }

      if (lc === "toggle collapse") {
        HTM.eventActive = !HTM.eventActive;
        consoleLog(`Attractor collapse ${HTM.eventActive ? "enabled" : "disabled"}`);
        return;
      }

      n = numAfter("jump t");
      if (n !== null) {
        timeMode = "scrub";
        const tSlider = document.getElementById("time-slider");
        const wrapped = ((n % 1) + 1) % 1;
        tSlider.value = wrapped;
        HTM.t = wrapped * 2 * Math.PI;
        consoleLog(`time scrubbed to phase ${wrapped.toFixed(3)}`);
        return;
      }

      if (lc === "mode live") {
        timeMode = "live";
        consoleSetStatus("live", "bg-sky-900/60 text-sky-300");
        document.getElementById("time-mode-btn").textContent = "live";
        return;
      }
      if (lc === "mode scrub") {
        timeMode = "scrub";
        consoleSetStatus("scrub", "bg-fuchsia-900/60 text-fuchsia-300");
        document.getElementById("time-mode-btn").textContent = "scrub";
        return;
      }

      if (lc === "freeze" || lc === "pause") {
        paused = true;
        consoleSetStatus("paused", "bg-slate-900/60 text-slate-300");
        return;
      }
      if (lc === "unfreeze" || lc === "resume") {
        paused = false;
        consoleSetStatus("live", "bg-sky-900/60 text-sky-300");
        return;
      }

      if (lc === "randomize") {
        randomizeSeeds();
        consoleLog("entropy and seed randomized");
        return;
      }

      
      if (lc === "status" || lc === "ordis" || lc === "phi") {
        const affect = (MoE && MoE.metrics) ? MoE.metrics.affect.toFixed(2) : "0.00";
        const reasoning = (MoE && MoE.metrics) ? MoE.metrics.reasoning.toFixed(2) : "0.00";
        const regime = (MoE && MoE.metrics && MoE.metrics.regime) ? MoE.metrics.regime : "idle";
        const phiVal = (gravityProbe && typeof gravityProbe.phi === "number")
          ? gravityProbe.phi.toFixed(4)
          : "n/a";
        const curvVal = (gravityProbe && typeof gravityProbe.curv === "number")
          ? gravityProbe.curv.toFixed(4)
          : "n/a";
        consoleLog(
          `ensemble status → affect=${affect}, reasoning=${reasoning}, φ=${phiVal}, curv=${curvVal}, regime=${regime}`,
          "info"
        );
        return;
      }

      if (lc === "mood") {
        const affect = (MoE && MoE.metrics) ? MoE.metrics.affect : 0.0;
        const reasoning = (MoE && MoE.metrics) ? MoE.metrics.reasoning : 0.0;
        let tone = "neutral";
        if (affect > 0.35 && reasoning > 0.35) tone = "engaged";
        else if (affect > 0.35) tone = "curious";
        else if (reasoning > 0.45) tone = "focused";
        else if (affect < -0.25) tone = "drained";
        consoleLog(
          `ensemble mood → tone=${tone}, affect=${affect.toFixed(2)}, reasoning=${reasoning.toFixed(2)}`,
          "info"
        );
        return;
      }

consoleLog("unrecognized command; type 'help' for options", "warn");
    }

    // ========= CAVITY MODE =========
    function cavityMode(x, y, t, entropy, seed) {
      if (!HTM.cavityEnabled) return 0;
      const r = Math.hypot(x, y);
      const theta = Math.atan2(y, x);
      const thetaPhi = Math.atan2(y, x + PHI * x + 1e-6);
      const m6 = Math.cos(6.0 * theta + t + 0.3 * seed);
      const m8 = Math.cos(8.0 * thetaPhi - t + 0.5 * seed);
      const envelope = Math.exp(-0.002 * r * r);
      const amp = HTM.cavityAmp * (0.4 + 0.6 * Math.tanh(entropy));
      return amp * (m6 + m8) * envelope;
    }

    // ========= METRIC WARP =========
    function baseWarp(x, y, t) {
      const curvature = 3.6;
      const s = HTM.seed;
      return curvature * (
        Math.sin(0.12 * x + 0.3 * t + 0.7 * s) +
        0.7 * Math.cos(0.09 * y - 0.2 * t + 0.5 * s) +
        0.4 * Math.sin(0.06 * (x + y) + 0.17 * t + 0.9 * s)
      ) * 0.33;
    }

    function getMetricWarp(x, y, t, entropy) {
      const base = baseWarp(x, y, t);
      const cav = cavityMode(x, y, t, entropy, HTM.seed);
      return base + cav * 40.0; // emphasize cavity ripple
    }

    function getJacobianSensitivity(i, j) {
      const cx = GRID_SIZE / 2;
      const cy = GRID_SIZE / 2;
      const dx = i - cx;
      const dy = j - cy;
      const r = Math.sqrt(dx * dx + dy * dy);
      return 0.12 + 0.9 * Math.max(0, 1 - r / (GRID_SIZE / 3.2));
    }

    function getAttentionMagnitude(i, j, t) {
      const s = HTM.seed;
      const wobble = Math.sin(t * 0.55 + 0.2 * s);
      const px = Math.floor(GRID_SIZE / 2 + (GRID_SIZE / 4) * wobble);
      const py = Math.floor(GRID_SIZE / 2 - (GRID_SIZE / 4) * wobble);
      const dx = i - px;
      const dy = j - py;
      const r2 = dx * dx + dy * dy;
      return Math.exp(-0.07 * r2);
    }

    // ========= HIDDEN STATE / EIGEN =========
    function updateHiddenState(dt) {
      const axis = new THREE.Vector3(0, 1, 0).normalize();
      const e = HTM.eigen;

      const stable = e.stable;
      const unstable = e.unstable;

      let stableMag = HTM.eventActive ? 0.5 : 1.0;
      let unstableMag = HTM.eventActive ? 0.9 : e.mu;

      const scaleStable = dt * 0.01;
      const scaleUnstable = dt * 0.01;

      stable.applyAxisAngle(axis, e.epsStable * 2 * Math.PI * scaleStable);
      stable.multiplyScalar(0.996 * stableMag);

      unstable.applyAxisAngle(axis, e.epsUnstable * 2 * Math.PI * scaleUnstable);
      unstable.multiplyScalar(unstableMag * 0.992 + 0.01);
    }

    function helix(mode, u, t) {
      const e = HTM.eigen;
      const isStable = mode === "stable";
      const h = isStable ? e.stable : e.unstable;
      const eps = isStable ? e.epsStable : e.epsUnstable;
      const dir = isStable ? 1 : -1;

      const r = 2.2 * h.length();
      const zWorld = u * (HTM.L - 1) * LAYER_SPACING;
      const theta = zWorld * eps * 0.26 + dir * t * 0.65;

      const x = r * Math.cos(theta);
      const y = zWorld;
      const z = r * Math.sin(theta);
      return new THREE.Vector3(x, y, z);
    }
    // ========= SYNAPTIC STREAMS (between eigenmode helices) =========
    const SynapseStreams = {
      group: null,
      lines: [],
      mids: [],
      lastInitCount: 0
    };

    function initSynapseStreams() {
      if (!scene || !HTM || !MoE) return;
      const experts = MoE.experts || [];
      if (!experts.length) return;

      if (!SynapseStreams.group) {
        SynapseStreams.group = new THREE.Group();
        SynapseStreams.group.name = "SynapseStreams";
        SynapseStreams.group.position.set(0, 0, 0);
        scene.add(SynapseStreams.group);
      }

      const targetCount = Math.max(1, experts.length * 3);
      if (SynapseStreams.lines.length === targetCount) return;

      // clear any existing lines if the expert count changed
      for (let i = 0; i < SynapseStreams.lines.length; i++) {
        SynapseStreams.group.remove(SynapseStreams.lines[i]);
      }
      SynapseStreams.lines.length = 0;

      for (let i = 0; i < targetCount; i++) {
        const geom = new THREE.BufferGeometry();
        const positions = new Float32Array(2 * 3);
        geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
        const mat = new THREE.LineBasicMaterial({
          color: 0x53bba5,
          transparent: true,
          opacity: 0.35,
          linewidth: 2.5
        });
        const line = new THREE.Line(geom, mat);
        SynapseStreams.group.add(line);
        SynapseStreams.lines.push(line);
      }
      SynapseStreams.lastInitCount = targetCount;
    }

    function updateSynapseStreams(time) {
      if (!MoE || !Array.isArray(MoE.synapticFlux) || MoE.synapticFlux.length === 0) return;
      initSynapseStreams();
      if (!SynapseStreams.group || SynapseStreams.lines.length === 0) return;

      const n = SynapseStreams.lines.length;
      const flux = MoE.synapticFlux;
      if (!Array.isArray(SynapseStreams.mids) || SynapseStreams.mids.length !== n) {
        SynapseStreams.mids = new Array(n);
      }

      const fluxLen = flux.length;

      for (let i = 0; i < n; i++) {
        const line = SynapseStreams.lines[i];
        const geom = line.geometry;
        const pos = geom.attributes.position.array;

        const u = (i + 0.5) / n;
        const a = helix("stable", u, time);
        const b = helix("unstable", u, time);
        const mid = new THREE.Vector3().addVectors(a, b).multiplyScalar(0.5);
        SynapseStreams.mids[i] = mid.clone();

        // push endpoints slightly outward so the streams float around the helices
        const dir = new THREE.Vector3().subVectors(b, a).normalize();
        const offset = dir.clone().multiplyScalar(0.6);
        const p0 = new THREE.Vector3().subVectors(mid, offset);
        const p1 = new THREE.Vector3().addVectors(mid, offset);

        pos[0] = p0.x; pos[1] = p0.y; pos[2] = p0.z;
        pos[3] = p1.x; pos[4] = p1.y; pos[5] = p1.z;
        geom.attributes.position.needsUpdate = true;

        const fluxVal = fluxLen > 0 ? (flux[i % fluxLen] || 0.0) : 0.0;
        const f = THREE.MathUtils.clamp(Math.abs(fluxVal), 0.0, 1.5);
        const mat = line.material;

        // base opacity from flux with a fast local flicker to feel like plasma.
        // During storms we add extra jitter along the helix direction.
        const alphaBase = 0.3 + 0.6 * THREE.MathUtils.smoothstep(f, 0.0, 1.2);

        let stormLevel = 0.0;
        if (MoE && MoE.metrics && typeof MoE.metrics.synapticMass === "number") {
          const synMass = MoE.metrics.synapticMass;
          stormLevel = THREE.MathUtils.clamp(synMass / (1.0 + synMass), 0.0, 1.0);
        }

        const jitter = 0.85 + 0.25 * Math.sin(time * (8.0 + 6.0 * stormLevel) + i * 0.9);
        mat.opacity = alphaBase * jitter;

        // color: teal for positive (affective pull), magenta for negative (reasoning push)
        const sign = fluxVal >= 0 ? 1 : -1;
        const teal = new THREE.Color(0x53bba5);
        const magenta = new THREE.Color(0xff4bd1);
        const mix = (sign > 0) ? 0.25 + 0.5 * Math.min(f, 1.0) : 0.75 + 0.2 * Math.min(f, 1.0);
        mat.color.copy(teal.clone().lerp(magenta, sign > 0 ? mix : 1.0 - mix));
      }
    }


    
    // ========= SYNAPTIC NETWORK (midpoint-to-midpoint connections) =========
    const SynapseNetwork = {
      group: null,
      lines: []
    };

    function initSynapseNetwork() {
      if (!scene || !SynapseStreams || !Array.isArray(SynapseStreams.mids)) return;
      const mids = SynapseStreams.mids;
      const n = mids.length;
      if (n < 2) return;

      if (!SynapseNetwork.group) {
        SynapseNetwork.group = new THREE.Group();
        SynapseNetwork.group.name = "SynapseNetwork";
        scene.add(SynapseNetwork.group);
      }

      const targetCount = Math.max(0, n - 1);
      if (SynapseNetwork.lines.length === targetCount) return;

      // reset lines if topology changed
      for (let i = 0; i < SynapseNetwork.lines.length; i++) {
        SynapseNetwork.group.remove(SynapseNetwork.lines[i]);
      }
      SynapseNetwork.lines.length = 0;

      for (let i = 0; i < targetCount; i++) {
        const geom = new THREE.BufferGeometry();
        const positions = new Float32Array(2 * 3);
        geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
        const mat = new THREE.LineBasicMaterial({
          color: 0xffa8ff,
          transparent: true,
          opacity: 0.0,
          linewidth: 3.0
        });
        const line = new THREE.Line(geom, mat);
        SynapseNetwork.group.add(line);
        SynapseNetwork.lines.push(line);
      }
    }

    function updateSynapseNetwork(time) {
      if (!SynapseStreams || !Array.isArray(SynapseStreams.mids)) return;
      const mids = SynapseStreams.mids;
      const n = mids.length;
      if (n < 2) return;
      initSynapseNetwork();
      if (!SynapseNetwork.group || SynapseNetwork.lines.length === 0) return;

      const flux = MoE && Array.isArray(MoE.synapticFlux) ? MoE.synapticFlux : null;

      // global activity metrics for storms + topology changes
      let avgFlux = 0.0;
      if (flux && flux.length > 0) {
        let acc = 0.0;
        for (let k = 0; k < flux.length; k++) acc += Math.abs(flux[k] || 0.0);
        avgFlux = acc / flux.length;
      }
      const synMass = (MoE && MoE.metrics && typeof MoE.metrics.synapticMass === "number") ? MoE.metrics.synapticMass : 0.0;
      const synLevel = THREE.MathUtils.clamp(synMass / (1.0 + synMass), 0.0, 1.0);
      const storm = THREE.MathUtils.clamp(avgFlux * 1.4 + synLevel * 0.8, 0.0, 2.0);

      // two families of chords so activity clearly flows side-to-side, not just along the stack,
      // with slow topology drift to mimic pruning / regrowth
      const chordSkipBase = Math.max(2, Math.floor(n / 6)); // wrap-around step
      const topoPhase = time * 0.15;

      for (let i = 0; i < SynapseNetwork.lines.length; i++) {
        const midA = mids[i];
        if (!midA) continue;

        // alternate between local neighbor and a more lateral partner with slow drift
        const localIdx = (i + 1) % n;
        const wave = 0.5 * (1.0 + Math.sin(topoPhase + i * 0.37));
        const dynamicSkip = Math.max(2, Math.floor(2 + wave * chordSkipBase));
        const lateralIdx = (i + dynamicSkip) % n;
        const j = (i % 2 === 0) ? localIdx : lateralIdx;
        const midB = mids[j];
        if (!midB) continue;

        const line = SynapseNetwork.lines[i];
        const geom = line.geometry;
        const pos = geom.attributes.position.array;

        pos[0] = midA.x; pos[1] = midA.y; pos[2] = midA.z;
        pos[3] = midB.x; pos[4] = midB.y; pos[5] = midB.z;
        geom.attributes.position.needsUpdate = true;

        // network brightness based on combined local flux, with a travelling pulse
        let f = 0.0;
        if (flux && flux.length > 0) {
          const fa = Math.abs(flux[i % flux.length] || 0.0);
          const fb = Math.abs(flux[j % flux.length] || 0.0);
          f = THREE.MathUtils.clamp(0.5 * (fa + fb), 0.0, 2.0);
        }

        // pulse speed tied to global synaptic mass and storm level
        const vPulse = 1.2 + 3.5 * synLevel + 2.5 * Math.min(storm, 1.5);
        const phase = time * vPulse - i * 0.65;
        const wavePulse = 0.5 * (1.0 + Math.sin(phase)); // 0..1 travelling along index

        // base transparency from local flux, boosted strongly during storms
        const baseAlpha = 0.2 + 0.55 * THREE.MathUtils.smoothstep(f, 0.0, 1.5);
        const stormBoost = 0.4 + 0.5 * Math.min(storm, 1.0);
        line.material.opacity = baseAlpha * (0.55 + 0.9 * wavePulse) * stormBoost;
      }
    }

    // ========= SYNAPTIC DOWNLINKS (electric streams to gravity sheet) =========
    const SynapseDownlinks = {
      group: null,
      lines: []
    };

    function initSynapseDownlinks() {
      if (!scene || !SynapseStreams || !Array.isArray(SynapseStreams.mids)) return;
      const mids = SynapseStreams.mids;
      const n = mids.length;
      if (n === 0) return;

      if (!SynapseDownlinks.group) {
        SynapseDownlinks.group = new THREE.Group();
        SynapseDownlinks.group.name = "SynapseDownlinks";
        scene.add(SynapseDownlinks.group);
      }

      const targetCount = n;
      if (SynapseDownlinks.lines.length === targetCount) return;

      for (let i = 0; i < SynapseDownlinks.lines.length; i++) {
        SynapseDownlinks.group.remove(SynapseDownlinks.lines[i]);
      }
      SynapseDownlinks.lines.length = 0;

      for (let i = 0; i < targetCount; i++) {
        const geom = new THREE.BufferGeometry();
        const positions = new Float32Array(2 * 3);
        geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
        const mat = new THREE.LineBasicMaterial({
          color: 0xfff1a1,
          transparent: true,
          opacity: 0.0,
          linewidth: 2.0
        });
        const line = new THREE.Line(geom, mat);
        SynapseDownlinks.group.add(line);
        SynapseDownlinks.lines.push(line);
      }
    }

    function updateSynapseDownlinks(time) {
      if (!SynapseStreams || !Array.isArray(SynapseStreams.mids)) return;
      const mids = SynapseStreams.mids;
      const n = mids.length;
      if (n === 0) return;
      if (!MoE || !Array.isArray(MoE.synapticFlux)) return;

      initSynapseDownlinks();
      if (!SynapseDownlinks.group || SynapseDownlinks.lines.length === 0) return;

      const flux = MoE.synapticFlux;
      const centerY = (HTM && HTM.L) ? (HTM.L - 1) * LAYER_SPACING * 0.5 : 0.0;
      const skullCenter = new THREE.Vector3(0, centerY, 0);
      const skullR = SPHERE_RADIUS * 0.96;

      for (let i = 0; i < n; i++) {
        const mid = mids[i];
        if (!mid) continue;

        const line = SynapseDownlinks.lines[i];
        const geom = line.geometry;
        const pos = geom.attributes.position.array;

        // project from skull center through synapse midpoint out to skull inner surface
        const rel = new THREE.Vector3().subVectors(mid, skullCenter);
        const rLen = rel.length() || 1.0;
        const dir = rel.multiplyScalar(1.0 / rLen);
        const skullHit = new THREE.Vector3().addVectors(skullCenter, dir.multiplyScalar(skullR));

        pos[0] = mid.x;      pos[1] = mid.y;      pos[2] = mid.z;
        pos[3] = skullHit.x; pos[4] = skullHit.y; pos[5] = skullHit.z;
        geom.attributes.position.needsUpdate = true;

        const f = THREE.MathUtils.clamp(Math.abs(flux[i] || 0.0), 0.0, 2.0);
        const base = 0.25;
        const alpha = base + 0.7 * THREE.MathUtils.smoothstep(f, 0.0, 1.5);
        const mat = line.material;
        mat.opacity = alpha;

        // subtle electric flicker via time and flux
        const phase = time * 6.0 + i * 0.7;
        const flicker = 0.85 + 0.2 * Math.sin(phase);
        mat.opacity *= flicker;
      }
    }

// ========= GLOBAL FRAME =========
    function setupGlobalFrame() {
      // Use a spherical manifold just inside the mirror sphere, so Φ lives on the inner "skull"
      const geom = new THREE.SphereGeometry(SPHERE_RADIUS * 0.96, 72, 72);
      const mat = new THREE.MeshPhongMaterial({
        color: 0x020617,
        specular: 0x1f2937,
        shininess: 18,
        side: THREE.BackSide,
        wireframe: false,
        transparent: true,
        opacity: 0.82
      });
      const manifold = new THREE.Mesh(geom, mat);

      const centerY = (HTM.L - 1) * LAYER_SPACING * 0.5;
      manifold.position.set(0, centerY, 0);
      scene.add(manifold);
      sim.manifold = manifold;
      sim.manifoldSize = {
        width: SPHERE_RADIUS * 2.0,
        height: SPHERE_RADIUS * 2.0
      };

      // Gravity grid overlay that shares the same geometry (bends with Φ) as an inner wireframe shell
      const gridMat = new THREE.MeshBasicMaterial({
        color: 0x38bdf8,
        wireframe: true,
        transparent: true,
        opacity: 0.5
      });
      const gravityGrid = new THREE.Mesh(geom, gridMat);
      gravityGrid.position.copy(manifold.position);
      scene.add(gravityGrid);
      sim.gravityGrid = gravityGrid;

      const fogColor = new THREE.Color(0x020617);
      scene.fog = new THREE.FogExp2(fogColor, 0.006);
      renderer.setClearColor(fogColor);

      const key = new THREE.SpotLight(0x22d3ee, 3.3, 450, Math.PI / 4, 0.4, 2);
      key.position.set(80, 140, 110);
      scene.add(key);

      const fill = new THREE.PointLight(0xf97316, 1.8, 260);
      fill.position.set(-90, 40, -80);
      scene.add(fill);

      const rim = new THREE.PointLight(0xa855f7, 1.4, 260);
      rim.position.set(40, 160, -40);
      scene.add(rim);

      const ambient = new THREE.AmbientLight(0xffffff, 0.15);
      scene.add(ambient);
    }

    
    function updateGlobalFrame(time) {
      const manifold = sim.manifold;
      if (!manifold) return;
      const geom = manifold.geometry;
      const pos = geom.attributes.position;
      const vertexCount = pos.count;
      let curvLevel = 0.0;

      // Plane segments must match setupGlobalFrame
      const segments = 72;
      const nx = segments + 1;
      const ny = segments + 1;

      if (vertexCount !== nx * ny) {
        // Fallback: keep old warped surface if geometry changes in a future version
        const midIdx = Math.floor(HTM.L / 2);
        const midEntropy = HTM.layers[midIdx]?.entropy ?? 1.0;
        for (let i = 0; i < vertexCount; i++) {
          const x = pos.getX(i);
          const y = pos.getY(i);
          const warp = getMetricWarp(x, y, time, midEntropy);
          pos.setZ(i, warp * 2.1);
        }
        pos.needsUpdate = true;
        geom.computeVertexNormals();
        return;
      }

      // === 1. Build an effective mass distribution from HTM layer entropies ===
      const masses = [];
      const massPos = [];
      const L = HTM.L;
      const cx = (nx - 1) / 2;

      for (let l = 0; l < L; l++) {
        const layer = HTM.layers[l];
        if (!layer) continue;
        const H = layer.entropy ?? 1.0;
        const m = 0.04 * Math.max(H, 0.05);
        const frac = (L === 1) ? 0.5 : l / (L - 1);
        const yIdx = frac * (ny - 1);
        masses.push(m);
        massPos.push({ x: cx, y: yIdx });
      }
      // === 1b. Add synaptic mass from MoE experts as real synaptic streams ===
      if (MoE && Array.isArray(MoE.synapticFlux) && MoE.synapticFlux.length > 0) {
        const numSyn = MoE.synapticFlux.length;
        const width = sim.manifoldSize.width;
        const height = sim.manifoldSize.height;
        const density = 3; // oversample each synaptic channel along the helix
        // place synaptic sources along the double helix midline, mapped onto the gravity grid
        for (let s = 0; s < numSyn; s++) {
          const flux = MoE.synapticFlux[s] || 0.0;
          const amp = Math.abs(flux);
          if (amp < 1e-4) continue;

          for (let k = 0; k < density; k++) {
            const u = (s + (k + 0.5) / density) / numSyn;
            const a = helix("stable", u, time);
            const b = helix("unstable", u, time);
            const mid = new THREE.Vector3().addVectors(a, b).multiplyScalar(0.5);

            // project helix midpoint into manifold grid coordinates
            const localX = THREE.MathUtils.clamp((mid.x / width) + 0.5, 0.0, 1.0);
            const localY = THREE.MathUtils.clamp((mid.z / height) + 0.5, 0.0, 1.0);
            const iGrid = localX * (nx - 1);
            const jGrid = localY * (ny - 1);

            // signed synaptic mass: affect streams pull (positive), reasoning can both pull or push
            const sign = flux >= 0 ? 1.0 : -1.0;
            const mSyn = sign * (0.6 + 9.0 * amp) / density;

            masses.push(mSyn);
            massPos.push({ x: iGrid, y: jGrid });
          }
        }
      }


      // === 2. Compute Newtonian potential Φ on the lattice (weak-field GR units) ===
      // We treat each mass entry as an effective rest-mass source in kg via M_UNIT
      const potential = new Array(vertexCount);
      let phiMin = Infinity;
      let phiMax = -Infinity;

      for (let j = 0; j < ny; j++) {
        for (let i = 0; i < nx; i++) {
          const idx = j * nx + i;
          let phi = 0.0;
          for (let k = 0; k < masses.length; k++) {
            const dxGrid = i - massPos[k].x;
            const dyGrid = j - massPos[k].y;
            const rGrid2 = dxGrid * dxGrid + dyGrid * dyGrid + 4.0; // softening in grid units
            const rGrid = Math.sqrt(rGrid2);
            const rPhys = rGrid * L_UNIT;          // meters
            const mPhys = masses[k] * M_UNIT;      // kg
            phi += -G_PHYS * mPhys / rPhys;        // m^2 / s^2
          }
          potential[idx] = phi;
          if (phi < phiMin) phiMin = phi;
          if (phi > phiMax) phiMax = phi;
        }
      }


// === 3. Approximate curvature via discrete Laplacian of Φ (weak-field Einstein 00) ===
      const curvature = new Array(vertexCount).fill(0.0);

      // grid spacing in meters (we use L_UNIT per index step)
      const dxPhys = L_UNIT;
      const h2Phys = dxPhys * dxPhys;

      for (let j = 1; j < ny - 1; j++) {
        for (let i = 1; i < nx - 1; i++) {
          const idx = j * nx + i;
          const phiC = potential[idx];
          const phiL = potential[j * nx + (i - 1)];
          const phiR = potential[j * nx + (i + 1)];
          const phiD = potential[(j - 1) * nx + i];
          const phiU = potential[(j + 1) * nx + i];

          // discrete ∇²Φ in physical units (m/s^2)
          const lapPhi = (phiL + phiR + phiD + phiU - 4 * phiC) / h2Phys;

          // In the static weak-field limit, the Ricci scalar tracks ∇²Φ / c^2 up to sign.
          // We use R ≈ -2 ∇²Φ / c^2 as a visualization-friendly scalar curvature.
          const Rscalar = -2.0 * lapPhi / C2;
          curvature[idx] = Rscalar;
        }
      }


// === 4. Embed Φ as a spacetime surface: z ∝ Φ, normalized ===
      const range = (phiMax - phiMin) || 1.0;
      const synMass = (MoE && MoE.metrics && typeof MoE.metrics.synapticMass === "number") ? MoE.metrics.synapticMass : 0.0;
      const synFactor = THREE.MathUtils.clamp(synMass / (1.0 + synMass), 0.0, 1.0);
      const depthScale = 1.2 + 10.0 * synFactor;

      // Use curvature to drive a soft emissive gradient on the skull, so the cavity itself
      // glows more intensely in regions of high |curvature|.
      if (curvature && curvature.length === potential.length) {
        let curvAcc = 0.0;
        let curvMaxAbs = 0.0;
        const curvArr = curvature;
        const total = curvArr.length;
        for (let idxC = 0; idxC < total; idxC++) {
          const cVal = curvArr[idxC] || 0.0;
          const a = Math.abs(cVal);
          curvAcc += a;
          if (a > curvMaxAbs) curvMaxAbs = a;
        }
        const curvAvg = total > 0 ? (curvAcc / total) : 0.0;
        curvLevel = THREE.MathUtils.clamp(4.0 * curvAvg + 2.0 * curvMaxAbs, 0.0, 2.5);

        const mat = manifold.material;
        if (mat && mat.color) {
          // Map curvature+synFactor to an HSL band: deep blue -> teal -> violet.
          const h = 0.55 - 0.18 * synFactor + 0.12 * Math.min(curvLevel, 1.0); // hue
          const s = 0.6 + 0.2 * synFactor;
          const l = 0.26 + 0.18 * Math.min(curvLevel, 1.0);
          mat.color.setHSL(h, s, l);

          if (mat.emissive) {
            const emissiveBoost = 0.3 + 0.9 * Math.min(curvLevel, 1.0);
            const emissiveColor = new THREE.Color().setHSL(h + 0.05, 0.9, 0.5);
            mat.emissive.copy(emissiveColor.multiplyScalar(emissiveBoost));
          }
        }
      }

      OrdisSelf.synFactor = synFactor;
      OrdisSelf.curvLevel = curvLevel;
      // curvature "stress" — a scalar measuring how "bent" the skull is away from flat space
      OrdisSelf.curvStress = Math.abs(curvLevel - 1.0);

      // Embed Φ as a radial warp on the spherical manifold: radius ∝ Φ
      // and let the curvature carve visible "lobes" into the skull so it is no longer static.
      for (let j = 0; j < ny; j++) {
        for (let i = 0; i < nx; i++) {
          const idx = j * nx + i;
          const phiNorm = (potential[idx] - phiMin) / range; // 0..1
          const radialOffset = -phiNorm * depthScale;

          const vx = pos.getX(idx);
          const vy = pos.getY(idx);
          const vz = pos.getZ(idx);
          const r = Math.sqrt(vx * vx + vy * vy + vz * vz) || 1.0;

          // latitude (y / r) and a simple quadrupole harmonic to imprint anisotropy
          const yhat = vy / r;
          const quad = 1.5 * yhat * yhat - 0.5; // ~Y20

          // skull "breathes" with global synaptic mass and bends with curvature
          const baseR = SPHERE_RADIUS * (0.94 - 0.08 * synFactor);
          const lobeScale = 1.0 + 0.9 * quad * (curvLevel - 1.0);
          const newR = (baseR + radialOffset) * lobeScale;
          const s = newR / r;

          pos.setXYZ(idx, vx * s, vy * s, vz * s);
        }
      }

      pos.needsUpdate = true;
      geom.computeVertexNormals();

      // Store field for external inspection / HUD and mirror coupling
      sim.gravityField = {
        nx,
        ny,
        potential,
        curvature,
        phiMin,
        phiMax,
        lastTime: time
      };

      // Also let the outer mirror skull follow the same field-driven deformation,
      // so reflections and photon paths live in the same curved cavity.
      if (sim.mirrorSphere && sim.mirrorSphere.sphere) {
        const ms = sim.mirrorSphere;
        const sphere = ms.sphere;
        const g = sphere.geometry;
        const pAttr = g.attributes.position;
        const vCount = pAttr.count;

        // effective field summary for the mirror deformation
        const syn = synFactor;
        const curvEff = curvLevel;
        const depthScaleMirror = 4.0 + 24.0 * syn;

        for (let idx = 0; idx < vCount; idx++) {
          const vx = pAttr.getX(idx);
          const vy = pAttr.getY(idx);
          const vz = pAttr.getZ(idx);
          const r = Math.sqrt(vx * vx + vy * vy + vz * vz) || 1.0;

          const yhat = vy / r;
          const quad = 1.5 * yhat * yhat - 0.5;

          // use a smoothed "average" potential encoded via curvature + synaptic mass
          const phiEff = 0.5 + 0.5 * Math.tanh(2.0 * (curvEff - 1.0));
          const radialOffsetM = -phiEff * depthScaleMirror;

          const baseR = SPHERE_RADIUS * (0.995 - 0.05 * syn);
          const lobeScale = 1.0 + 1.1 * quad * (curvEff - 1.0);
          const newR = (baseR + radialOffsetM) * lobeScale;
          const s = newR / r;

          pAttr.setXYZ(idx, vx * s, vy * s, vz * s);
        }

        pAttr.needsUpdate = true;
        g.computeVertexNormals();
      }
    }

    function updateGravityHeatmap() {
      const canvas = document.getElementById("gravity-heatmap");
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;

      const field = sim.gravityField;
      if (!field || !field.potential || !field.nx || !field.ny) {
        ctx.fillStyle = "#020617";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        return;
      }

      const { nx, ny, potential, phiMin, phiMax, curvature } = field;
      const w = canvas.width;
      const h = canvas.height;
      const range = (phiMax - phiMin) || 1.0;

      const img = ctx.createImageData(w, h);
      const data = img.data;

      for (let y = 0; y < h; y++) {
        const v = y / (h - 1);
        const j = Math.floor(v * (ny - 1));
        for (let x = 0; x < w; x++) {
          const u = x / (w - 1);
          const i = Math.floor(u * (nx - 1));
          const idxField = j * nx + i;
          const phi = potential[idxField];
          const t = (phi - phiMin) / range; // 0..1

          // curvature-aware colormap: Φ sets the base, curvature sharpens edges in magenta
          let k = 0.0;
          if (curvature && curvature.length === nx * ny) {
            k = Math.min(1.0, Math.abs(curvature[idxField]) * 4.0);
          }

          // base blue->cyan->yellow map from Φ
          const c1 = Math.max(0, 1 - 2 * t);      // blue component
          const c2 = Math.max(0, 2 * t - 0.2);    // green
          const c3 = Math.max(0, 2 * t - 0.8);    // red

          // blend in curvature as a magenta halo on high-curvature regions
          const r = Math.floor(255 * (c3 + 0.55 * k));
          const g = Math.floor(255 * (c2 * (1.0 - 0.4 * k)));
          const b = Math.floor(255 * (c1 + 0.35 * k));

          const idxImg = (y * w + x) * 4;
          data[idxImg] = r;
          data[idxImg + 1] = g;
          data[idxImg + 2] = b;
          data[idxImg + 3] = 255;
        }
      }

      ctx.putImageData(img, 0, 0);
    }

    function updateGravityProbe(time) {
      const field = sim.gravityField;
      const manifold = sim.manifold;
      const size = sim.manifoldSize;
      if (!field || !manifold || !size) return;

      const coordsEl = document.getElementById("gp-coords");
      const phiEl = document.getElementById("gp-phi");
      const curvEl = document.getElementById("gp-curv");
      const g00El = document.getElementById("gp-g00");
      const g11El = document.getElementById("gp-g11");

      const nx = field.nx;
      const ny = field.ny;
      const potential = field.potential;
      const curvature = field.curvature;

      if (!potential || !nx || !ny) {
        if (coordsEl) coordsEl.textContent = "i=- j=-";
        if (phiEl) phiEl.textContent = "-";
        if (curvEl) curvEl.textContent = "-";
        if (g00El) g00El.textContent = "-";
        if (g11El) g11El.textContent = "-";
        return;
      }

      // Automatically probe the hottest point in the field: max |φ|
      let bestI = 0;
      let bestJ = 0;
      let bestAbs = -Infinity;

      for (let j = 0; j < ny; j++) {
        for (let i = 0; i < nx; i++) {
          const idx = j * nx + i;
          const val = potential[idx];
          const a = Math.abs(val);
          if (a > bestAbs) {
            bestAbs = a;
            bestI = i;
            bestJ = j;
          }
        }
      }

      const idx = bestJ * nx + bestI;
      const phi = potential[idx];
      const curv = curvature && curvature.length ? (curvature[idx] ?? 0.0) : 0.0;

      // Weak-field metric in physical units: g00 ≈ -(1 + 2Φ/c^2), g11 ≈ 1 - 2Φ/c^2
      const phiNorm = phi / C2;
      const g00 = -(1 + 2 * phiNorm);
      const g11 = 1 - 2 * phiNorm;

      gravityProbe.i = bestI;
      gravityProbe.j = bestJ;
      gravityProbe.phi = phi;
      gravityProbe.curv = curv;
      gravityProbe.g00 = g00;
      gravityProbe.g11 = g11;

      if (coordsEl) coordsEl.textContent = `i=${bestI} j=${bestJ}`;
      if (phiEl) phiEl.textContent = phi.toFixed(4);
      if (curvEl) curvEl.textContent = curv.toFixed(4);
      if (g00El) g00El.textContent = g00.toFixed(4);
      if (g11El) g11El.textContent = g11.toFixed(4);
    }

    // ========= EIGEN HELICES =========
    function setupEigenHelices() {
      const count = 260;
      const geom = new THREE.BufferGeometry();
      const verts = new Float32Array(count * 2 * 3);
      const cols = new Float32Array(count * 2 * 3);

      const cStable = new THREE.Color(0x38bdf8);
      const cUnstable = new THREE.Color(0xf97316);

      for (let i = 0; i < count * 2; i++) {
        const idx = i * 3;
        verts[idx] = verts[idx + 1] = verts[idx + 2] = 0;
        const c = i < count ? cStable : cUnstable;
        cols[idx] = c.r;
        cols[idx + 1] = c.g;
        cols[idx + 2] = c.b;
      }

      geom.setAttribute("position", new THREE.BufferAttribute(verts, 3));
      geom.setAttribute("color", new THREE.BufferAttribute(cols, 3));

      const mat = new THREE.PointsMaterial({
        size: 1.5,
        vertexColors: true,
        transparent: true,
        opacity: 0.95,
        blending: THREE.AdditiveBlending
      });

      const points = new THREE.Points(geom, mat);
      scene.add(points);
      sim.eigen = points;

      const stableMeta = [];
      const unstableMeta = [];
      for (let i = 0; i < count; i++) {
        stableMeta.push({ offset: i / count });
        unstableMeta.push({ offset: i / count });
      }
      points.userData.stable = stableMeta;
      points.userData.unstable = unstableMeta;
    }

    function updateEigenHelices(time, dt) {
      updateHiddenState(dt);
      const pts = sim.eigen;
      const pos = pts.geometry.attributes.position;
      const stable = pts.userData.stable;
      const unstable = pts.userData.unstable;
      const count = stable.length;
      let index = 0;

      for (let i = 0; i < count; i++) {
        const u = (time * 0.055 + stable[i].offset) % 1.0;
        const p = helix("stable", u, time);
        pos.setXYZ(index++, p.x, p.y, p.z);
      }
      for (let i = 0; i < count; i++) {
        const u = (time * 0.055 + unstable[i].offset + 0.2) % 1.0;
        const p = helix("unstable", u, time);
        pos.setXYZ(index++, p.x, p.y, p.z);
      }
      pos.needsUpdate = true;
    }

    // ========= MÖBIUS RIBBON =========
    function setupMobius() {
      const segU = 140;
      const segV = 14;
      const geom = new THREE.PlaneGeometry(1, 1, segU, segV);
      geom.parameters.heightSegments = segU;
      geom.parameters.widthSegments = segV;

      const mat = new THREE.MeshPhongMaterial({
        color: 0xfff7c2,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.3,
        emissive: 0xfacc15,
        emissiveIntensity: 0.7
      });

      const mesh = new THREE.Mesh(geom, mat);
      scene.add(mesh);
      sim.mobius = mesh;
    }

    function updateMobius(time) {
      const mob = sim.mobius;
      const geom = mob.geometry;
      const pos = geom.attributes.position;
      const segU = geom.parameters.heightSegments;
      const segV = geom.parameters.widthSegments;
      const width = 5.5;

      let idx = 0;
      for (let iu = 0; iu <= segU; iu++) {
        const u = iu / segU;
        const pS = helix("stable", u, time);
        const pU = helix("unstable", u, time);
        const center = pS.clone().add(pU).multiplyScalar(0.5);
        const tangent = pU.clone().sub(pS).normalize();
        const up = new THREE.Vector3(0, 1, 0);
        let normal = up.clone().sub(tangent.clone().multiplyScalar(up.dot(tangent))).normalize();
        const binorm = tangent.clone().cross(normal).normalize();
        const twistAngle = Math.PI * u;

        for (let iv = 0; iv <= segV; iv++) {
          const v = iv / segV - 0.5;
          const ct = Math.cos(twistAngle);
          const st = Math.sin(twistAngle);
          const twisted = normal.clone().multiplyScalar(ct).add(binorm.clone().multiplyScalar(st));
          const offset = twisted.multiplyScalar(width * v);
          const p = center.clone().add(offset);
          pos.setXYZ(idx++, p.x, p.y, p.z);
        }
      }
      pos.needsUpdate = true;
      geom.computeVertexNormals();

      const tCollapse = THREE.MathUtils.clamp(-HTM.recognitionDelta, 0, 1);
      const hue = 0.12 + 0.12 * tCollapse;
      const lightness = 0.45 + 0.25 * tCollapse;
      mob.material.color.setHSL(hue, 1, lightness);
      mob.material.emissiveIntensity = 0.5 + 1.0 * tCollapse;
    }

    // ========= ATTENTION LINKS =========
    function setupLinks() {
      const links = [];
      const N = 64;
      for (let k = 0; k < N; k++) {
        const geom = new THREE.BufferGeometry();
        geom.setAttribute("position", new THREE.BufferAttribute(new Float32Array(12), 3));
        const mat = new THREE.LineBasicMaterial({
          color: 0xff8800,
          transparent: true,
          opacity: 0.35,
          linewidth: 2.5,
          blending: THREE.AdditiveBlending
        });
        const mesh = new THREE.LineSegments(geom, mat);
        scene.add(mesh);
        links.push({
          mesh,
          i: Math.floor(Math.random() * GRID_SIZE),
          j: Math.floor(Math.random() * GRID_SIZE)
        });
      }
      sim.links = links;
    }

    function updateLinks(time) {
      const links = sim.links;
      const y0 = LAYER_SPACING * 1.2;
      const y1 = LAYER_SPACING * (HTM.L - 2);

      links.forEach((link, idx) => {
        const mag = getAttentionMagnitude(link.i, link.j, time);
        const sens = getJacobianSensitivity(link.i, link.j);
        const phase = idx / links.length;
        const baseR = 10 + mag * 18;
        const ang = time * 0.6 + phase * 2 * Math.PI;

        const s = new THREE.Vector3(
          baseR * Math.cos(ang),
          y0 + 4 * Math.sin(time * 0.6 + phase * 3.2),
          baseR * Math.sin(ang)
        );
        const e = new THREE.Vector3(
          baseR * Math.cos(ang + 0.5),
          y1 + 6 * Math.cos(time * 0.4 + phase * 4.1),
          baseR * Math.sin(ang + 0.5)
        );
        const mid = s.clone().lerp(e, 0.5);
        mid.x += Math.sin(time * 20 + phase * 6.0) * sens * 2.4;

        const p = link.mesh.geometry.attributes.position;
        p.setXYZ(0, s.x, s.y, s.z);
        p.setXYZ(1, mid.x, mid.y, mid.z);
        p.setXYZ(2, mid.x, mid.y, mid.z);
        p.setXYZ(3, e.x, e.y, e.z);
        p.needsUpdate = true;

        const hue = 0.07 + mag * 0.2;
        const lightness = 0.35 + 0.35 * sens;
        link.mesh.material.color.setHSL(hue, 1, lightness);
        link.mesh.material.opacity = 0.12 + 0.7 * mag;
      });
    }

    // ========= MIRROR SPHERE + PHOTON / CRYSTAL CAVITY (ADDED) =========
    function setupMirrorSphere() {
      const centerY = (HTM.L - 1) * LAYER_SPACING * 0.5;
      const center = new THREE.Vector3(0, centerY, 0);

      const sphereGeo = new THREE.SphereGeometry(SPHERE_RADIUS, 64, 64);
      const sphereMat = new THREE.MeshPhysicalMaterial({
        color: 0x020617,
        metalness: 1.0,
        roughness: 0.05,
        reflectivity: 1.0,
        clearcoat: 1.0,
        clearcoatRoughness: 0.03,
        side: THREE.BackSide,
        envMapIntensity: 1.0
      });
      const sphere = new THREE.Mesh(sphereGeo, sphereMat);
      sphere.position.copy(center);
      scene.add(sphere);

      const photonGeo = new THREE.BufferGeometry();
      const photonPositions = new Float32Array(NUM_PHOTONS * 3);
      const photonColors = new Float32Array(NUM_PHOTONS * 3);
      const velocities = [];
      const wavelengths = [];

      for (let i = 0; i < NUM_PHOTONS; i++) {
        // random point inside sphere
        let p;
        while (true) {
          const x = (Math.random() * 2 - 1) * SPHERE_RADIUS * 0.9;
          const y = (Math.random() * 2 - 1) * SPHERE_RADIUS * 0.9;
          const z = (Math.random() * 2 - 1) * SPHERE_RADIUS * 0.9;
          p = new THREE.Vector3(x, y, z);
          if (p.length() <= SPHERE_RADIUS * 0.9) break;
        }
        p.add(center);
        photonPositions[3 * i] = p.x;
        photonPositions[3 * i + 1] = p.y;
        photonPositions[3 * i + 2] = p.z;

        // velocity
        const dir = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
        const baseSpeed = 1.0 + Math.random() * 0.4;
        velocities.push(dir.multiplyScalar(baseSpeed));

        // wavelength in [430, 680] nm
        const wl = 430 + Math.random() * 250;
        wavelengths.push(wl);

        // initial color
        const c = wavelengthToColor(wl);
        photonColors[3 * i] = c.r;
        photonColors[3 * i + 1] = c.g;
        photonColors[3 * i + 2] = c.b;
      }

      photonGeo.setAttribute("position", new THREE.BufferAttribute(photonPositions, 3));
      photonGeo.setAttribute("color", new THREE.BufferAttribute(photonColors, 3));
      const photonMat = new THREE.PointsMaterial({
        size: 1.5,
        vertexColors: true,
        transparent: true,
        opacity: 0.95,
        blending: THREE.AdditiveBlending
      });
      const photons = new THREE.Points(photonGeo, photonMat);
      scene.add(photons);

      // Crystals: refracting scatterers
      const crystals = [];
      for (let k = 0; k < NUM_CRYSTALS; k++) {
        const r = SPHERE_RADIUS * (0.25 + 0.55 * Math.random());
        const theta = Math.acos(2 * Math.random() - 1);
        const phi = 2 * Math.PI * Math.random();
        const pos = new THREE.Vector3(
          r * Math.sin(theta) * Math.cos(phi),
          r * Math.cos(theta),
          r * Math.sin(theta) * Math.sin(phi)
        ).add(center);

        const rad = 2.5 + Math.random() * 2.0;
        const crystalGeo = new THREE.OctahedronGeometry(rad, 0);
        const crystalColor = new THREE.Color().setHSL(0.5 + 0.2 * Math.random(), 0.8, 0.6);
        const crystalMat = new THREE.MeshPhysicalMaterial({
          color: crystalColor,
          metalness: 0.1,
          roughness: 0.08,
          transmission: 0.85,
          transparent: true,
          opacity: 0.95,
          emissive: crystalColor,
          emissiveIntensity: 0.7,
          envMapIntensity: 1.2
        });
        const crystal = new THREE.Mesh(crystalGeo, crystalMat);
        crystal.position.copy(pos);
        scene.add(crystal);

        crystals.push({
          mesh: crystal,
          radius: rad * 1.2
        });
      }

      sim.mirrorSphere = {
        sphere,
        center,
        photons,
        photonPositions,
        photonColors,
        velocities,
        wavelengths,
        crystals
      };
    }

    function wavelengthToColor(wl) {
      // Simple visible-spectrum mapping (approximate)
      let r = 0, g = 0, b = 0;
      if (wl >= 380 && wl < 440) {
        r = -(wl - 440) / (440 - 380);
        g = 0;
        b = 1;
      } else if (wl >= 440 && wl < 490) {
        r = 0;
        g = (wl - 440) / (490 - 440);
        b = 1;
      } else if (wl >= 490 && wl < 510) {
        r = 0;
        g = 1;
        b = -(wl - 510) / (510 - 490);
      } else if (wl >= 510 && wl < 580) {
        r = (wl - 510) / (580 - 510);
        g = 1;
        b = 0;
      } else if (wl >= 580 && wl < 645) {
        r = 1;
        g = -(wl - 645) / (645 - 580);
        b = 0;
      } else if (wl >= 645 && wl <= 780) {
        r = 1;
        g = 0;
        b = 0;
      }
      const c = new THREE.Color(r, g, b);
      return c;
    }

    function updateMirrorSphere(time, dt) {
      const ms = sim.mirrorSphere;
      if (!ms) return;

      const positions = ms.photonPositions;
      const colors = ms.photonColors;
      const center = ms.center;
      const vel = ms.velocities;
      const wl = ms.wavelengths;
      const crystals = ms.crystals;

      // Coupling to HTM: mid-layer entropy modulates speed and brightness
      const midIdx = Math.floor(HTM.L / 2);
      const midEntropy = HTM.layers[midIdx]?.entropy ?? 1.0;
      const entropyNorm = THREE.MathUtils.clamp(midEntropy / 4.0, 0, 1);
      const speedScale = 16 + 18 * Math.tanh(midEntropy + 0.2) + 60 * HTM.cavityAmp;
      const brightness = 0.35 + 0.55 * entropyNorm * (HTM.cavityEnabled ? 1.2 : 0.7);

      for (let i = 0; i < NUM_PHOTONS; i++) {
        // position as Vector3
        const px = positions[3 * i];
        const py = positions[3 * i + 1];
        const pz = positions[3 * i + 2];
        const p = new THREE.Vector3(px, py, pz);
        const v = vel[i];

        // advance
        p.addScaledVector(v, dt * speedScale);

        // reflect off mirror sphere — use its *current* deformed radius
        const rel = p.clone().sub(center);
        const dist = rel.length();
        const sphereGeo = ms.sphere.geometry;
        if (sphereGeo && sphereGeo.boundingSphere === null) {
          sphereGeo.computeBoundingSphere();
        }
        const R = sphereGeo && sphereGeo.boundingSphere ? sphereGeo.boundingSphere.radius : SPHERE_RADIUS;

        if (dist > R * 0.995) {
          const n = rel.normalize();
          const dot = v.dot(n);
          v.addScaledVector(n, -2 * dot); // specular reflection
          p.copy(n.multiplyScalar(R * 0.99).add(center));
        }

        // interact with crystals: approximate refraction / diffusion
        for (let k = 0; k < crystals.length; k++) {
          const cPos = crystals[k].mesh.position;
          const radius = crystals[k].radius;
          const d = p.distanceTo(cPos);
          if (d < radius) {
            // normal at impact
            const n = p.clone().sub(cPos).normalize();
            // refracted / scattered direction
            const rotated = v.clone().applyAxisAngle(n, 0.6 + 0.4 * Math.random());
            v.lerp(rotated, 0.7);

            // small wavelength shift (like dispersion)
            wl[i] += (Math.random() - 0.5) * 6.0;
            wl[i] = THREE.MathUtils.clamp(wl[i], 430, 680);
          }
        }

        // write back position
        positions[3 * i] = p.x;
        positions[3 * i + 1] = p.y;
        positions[3 * i + 2] = p.z;

        // color from wavelength + brightness
        const col = wavelengthToColor(wl[i]);
        colors[3 * i] = col.r * brightness;
        colors[3 * i + 1] = col.g * brightness;
        colors[3 * i + 2] = col.b * brightness;
      }

      ms.photons.geometry.attributes.position.needsUpdate = true;
      ms.photons.geometry.attributes.color.needsUpdate = true;

      // mirror sphere glow responds to entropy & collapse
      const collapse = THREE.MathUtils.clamp(-HTM.recognitionDelta, 0, 1);
      ms.sphere.material.emissive = new THREE.Color().setHSL(0.55 + 0.1 * collapse, 0.8, 0.35 + 0.25 * collapse);
      ms.sphere.material.emissiveIntensity = 0.4 + 1.3 * entropyNorm * (HTM.cavityEnabled ? 1.0 : 0.6);
    }

    // ========= LAYERS & ENTROPY =========
    function setupLayers() {
      if (HTM.layers && HTM.layers.length) {
        HTM.layers.forEach((layer) => {
          scene.remove(layer.plane);
          scene.remove(layer.flow);
          scene.remove(layer.cloud);
        });
      }
      HTM.layers = [];

      for (let l = 0; l < HTM.L; l++) {
        const yPos = l * LAYER_SPACING;

        const planeGeo = new THREE.PlaneGeometry(GRID_SIZE, GRID_SIZE, 10, 10);
        const planeMat = new THREE.MeshBasicMaterial({
          color: 0x1d4ed8,
          side: THREE.DoubleSide,
          wireframe: true,
          transparent: true,
          opacity: 0.14
        });
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = Math.PI / 2;
        plane.position.y = yPos;
        scene.add(plane);

        const flowGeo = new THREE.BufferGeometry();
        const N = 80;
        const verts = new Float32Array(N * 3);
        for (let i = 0; i < verts.length; i += 3) {
          verts[i] = (Math.random() - 0.5) * GRID_SIZE;
          verts[i + 1] = 0;
          verts[i + 2] = (Math.random() - 0.5) * GRID_SIZE;
        }
        flowGeo.setAttribute("position", new THREE.BufferAttribute(verts, 3));
        const flowMat = new THREE.PointsMaterial({
          color: 0x22d3ee,
          size: 0.6,
          blending: THREE.AdditiveBlending,
          transparent: true,
          opacity: 0.9
        });
        const flow = new THREE.Points(flowGeo, flowMat);
        flow.position.y = yPos;
        scene.add(flow);

        const cloudGeo = new THREE.BufferGeometry();
        const C = 90;
        const cVerts = new Float32Array(C * 3);
        for (let i = 0; i < C; i++) {
          const theta = Math.random() * 2 * Math.PI;
          const r = 4 + Math.random() * 6;
          const x = r * Math.cos(theta);
          const z = r * Math.sin(theta);
          const jitter = (Math.random() - 0.5) * 2.5;
          cVerts[i * 3] = x;
          cVerts[i * 3 + 1] = jitter;
          cVerts[i * 3 + 2] = z;
        }
        cloudGeo.setAttribute("position", new THREE.BufferAttribute(cVerts, 3));
        const cloudMat = new THREE.PointsMaterial({
          color: 0x22c55e,
          size: 0.8,
          transparent: true,
          opacity: 0.25,
          blending: THREE.AdditiveBlending
        });
        const cloud = new THREE.Points(cloudGeo, cloudMat);
        cloud.position.y = yPos;
        scene.add(cloud);

        HTM.layers.push({
          plane,
          flow,
          cloud,
          entropy: Math.random() * 2.0
        });
      }

      document.getElementById("total-layers").textContent = HTM.L;
      const slider = document.getElementById("layer-slider");
      slider.max = Math.max(0, HTM.L - 1);
      if (HTM.currentLayer >= HTM.L) HTM.currentLayer = HTM.L - 1;
      slider.value = HTM.currentLayer;

      // if mirror sphere already exists, recenter it
      if (sim.mirrorSphere) {
        const centerY = (HTM.L - 1) * LAYER_SPACING * 0.5;
        sim.mirrorSphere.center.set(0, centerY, 0);
        sim.mirrorSphere.sphere.position.copy(sim.mirrorSphere.center);
      }
    }

    function updateEntropy(time, dt) {
      for (let l = 0; l < HTM.L; l++) {
        const layer = HTM.layers[l];
        layer.entropy += Math.sin(time * 0.35 + l * 0.85 + HTM.seed) * 0.012 * (1 + 0.2 * dt * 60);
        layer.entropy = Math.max(0, Math.min(4.0, layer.entropy));
      }
      const c = HTM.currentLayer;
      if (c < HTM.L - 1) {
        HTM.recognitionDelta = HTM.layers[c + 1].entropy - HTM.layers[c].entropy;
      } else {
        HTM.recognitionDelta = 0;
      }
    }

    function updateLayers(time) {
      HTM.layers.forEach((layer, l) => {
        const H = layer.entropy;
        const norm = Math.min(1, H / 4.0);
        const hue = 0.6 - norm * 0.6;
        const light = 0.3 + 0.18 * norm;
        layer.plane.material.color.setHSL(hue, 1, light);

        const pos = layer.flow.geometry.attributes.position;
        for (let i = 0; i < pos.count; i++) {
          let x = pos.getX(i);
          let z = pos.getZ(i);
          const w = 0.012 + 0.008 * l;
          const cR = Math.cos(w);
          const sR = Math.sin(w);
          const nx = x * cR - z * sR + Math.cos(time * 0.45 + l + HTM.seed) * 0.14;
          const nz = x * sR + z * cR + Math.sin(time * 0.45 + l * 1.2 + HTM.seed) * 0.14;
          x = Math.max(-GRID_SIZE / 2, Math.min(GRID_SIZE / 2, nx));
          z = Math.max(-GRID_SIZE / 2, Math.min(GRID_SIZE / 2, nz));
          pos.setX(i, x);
          pos.setZ(i, z);
        }
        pos.needsUpdate = true;

        const cPos = layer.cloud.geometry.attributes.position;
        const cavBoost = HTM.cavityEnabled ? 1.0 + 0.7 * Math.tanh(H) : 1.0;
        const scale = 1.0 + 0.05 * Math.sin(time * 1.2 + l * 0.8) * cavBoost;
        for (let i = 0; i < cPos.count; i++) {
          const x0 = cPos.getX(i);
          const y0 = cPos.getY(i);
          const z0 = cPos.getZ(i);
          cPos.setXYZ(i, x0 * scale, y0 * scale, z0 * scale);
        }
        cPos.needsUpdate = true;
        layer.cloud.material.opacity = 0.18 + 0.14 * norm * (HTM.cavityEnabled ? 1.2 : 1.0);
      });
    }

    // ========= UI SYNC & REGIME LABEL =========
    function updateRegimeLabel() {
      const mu = HTM.eigen.mu;
      const epsS = HTM.eigen.epsStable;
      const epsU = HTM.eigen.epsUnstable;

      const lamS_abs = 1.0; // e^{iθ} unit magnitude
      const lamU_abs = mu;

      const label = document.getElementById("regime-label");
      const lamLabel = document.getElementById("lambda-label");

      let regime = "recognition";
      let cls = "bg-emerald-900/60 text-emerald-300 mono";

      if (lamU_abs > 1.3 || epsU > 0.07) {
        regime = "hallucination";
        cls = "bg-fuchsia-900/60 text-fuchsia-300 mono";
      } else if (lamU_abs < 1.1 && epsU < 0.04 && epsS < 0.04) {
        regime = "drift / sleep";
        cls = "bg-indigo-900/60 text-indigo-300 mono";
      } else if (Math.abs(HTM.recognitionDelta) < 0.1) {
        regime = "critical / edge";
        cls = "bg-amber-900/60 text-amber-300 mono";
      }

      label.textContent = "regime: " + regime;
      label.className = "badge " + cls;
      lamLabel.textContent = `|λᵤ|=${lamU_abs.toFixed(2)} · |λₛ|≈${lamS_abs.toFixed(2)}`;
    }

    function syncUI() {
      const curr = HTM.currentLayer;
      const layer = HTM.layers[curr];
      document.getElementById("current-layer").textContent = curr + 1;
      document.getElementById("total-layers").textContent = HTM.L;
      document.getElementById("current-entropy").textContent = layer.entropy.toFixed(3);
      document.getElementById("recognition-delta").textContent = HTM.recognitionDelta.toFixed(3);
      const ev = document.getElementById("event-state");
      ev.textContent = HTM.eventActive ? "collapse" : "idle";
      ev.className = "mono " + (HTM.eventActive ? "text-red-400" : "text-slate-300");

      document.getElementById("param-mu").value = HTM.eigen.mu.toFixed(2);
      document.getElementById("param-eps-stable").value = HTM.eigen.epsStable.toFixed(3);
      document.getElementById("param-eps-unstable").value = HTM.eigen.epsUnstable.toFixed(3);
      document.getElementById("param-layers").value = HTM.L;
      document.getElementById("param-cavity-amp").value = HTM.cavityAmp.toFixed(3);

      const tSlider = document.getElementById("time-slider");
      if (timeMode === "scrub") {
        // manual scrub handled in event listener
      } else {
        tSlider.value = (HTM.t % (2 * Math.PI)) / (2 * Math.PI);
      }

      updateRegimeLabel();
    }

    function updateCavityButton() {
      const btn = document.getElementById("toggle-cavity");
      if (!btn) return;
      if (HTM.cavityEnabled) {
        btn.textContent = "Cavity: on";
        btn.className =
          "w-full bg-emerald-800/90 hover:bg-emerald-700 text-emerald-50 font-semibold py-1.5 px-3 rounded-md text-[0.7rem] transition duration-150";
      } else {
        btn.textContent = "Cavity: off";
        btn.className =
          "w-full bg-slate-800/95 hover:bg-slate-700 text-slate-100 font-semibold py-1.5 px-3 rounded-md text-[0.7rem] transition duration-150";
      }
    }

    // ========= PRESETS =========
    function applyPresetRecognition() {
      HTM.eigen.mu = 1.05;
      HTM.eigen.epsStable = 0.04;
      HTM.eigen.epsUnstable = 0.018;
      HTM.eventActive = false;
      HTM.cavityAmp = 0.018;
      HTM.cavityEnabled = true;
      HTM.seed = 1.234;
      HTM.layers.forEach((layer, l) => {
        const base = 1.0 + 0.1 * l;
        layer.entropy = base + 0.05 * Math.sin(l * 0.7);
      });
      consoleLog("preset: recognition");
    }

    function applyPresetChaos() {
      HTM.eigen.mu = 1.55;
      HTM.eigen.epsStable = 0.06;
      HTM.eigen.epsUnstable = 0.095;
      HTM.eventActive = true;
      HTM.cavityAmp = 0.05;
      HTM.cavityEnabled = true;
      HTM.seed = 4.2;
      HTM.layers.forEach((layer, l) => {
        const base = 2.0 + 0.8 * Math.sin(l * 1.2);
        layer.entropy = Math.min(4.0, base + 0.4 * Math.random());
      });
      consoleLog("preset: chaos/hallucination");
    }

    function applyPresetDrift() {
      HTM.eigen.mu = 1.12;
      HTM.eigen.epsStable = 0.03;
      HTM.eigen.epsUnstable = 0.028;
      HTM.eventActive = false;
      HTM.cavityAmp = 0.012;
      HTM.cavityEnabled = true;
      HTM.seed = 2.71;
      HTM.layers.forEach((layer, l) => {
        const base = 1.4 + 0.25 * Math.sin(l * 0.4);
        layer.entropy = base + 0.1 * Math.random();
      });
      consoleLog("preset: noisy drift");
    }

    function applyPresetCavity() {
      HTM.eigen.mu = 1.28;
      HTM.eigen.epsStable = 0.045;
      HTM.eigen.epsUnstable = 0.062;
      HTM.eventActive = false;
      HTM.cavityAmp = 0.08;
      HTM.cavityEnabled = true;
      HTM.seed = 3.14159;
      HTM.layers.forEach((layer, l) => {
        const base = 1.5 + 0.35 * Math.sin(l * 0.9);
        layer.entropy = base + 0.15 * Math.sin(l * 1.7 + HTM.seed);
      });
      consoleLog("preset: photon cavity box");
    }

    function applyPresetSleep() {
      HTM.eigen.mu = 1.02;
      HTM.eigen.epsStable = 0.02;
      HTM.eigen.epsUnstable = 0.018;
      HTM.eventActive = false;
      HTM.cavityAmp = 0.01;
      HTM.cavityEnabled = true;
      HTM.seed = 0.5;
      HTM.layers.forEach((layer, l) => {
        const base = 0.9 + 0.15 * Math.cos(l * 0.6);
        layer.entropy = base + 0.05 * Math.sin(l * 0.4 + HTM.seed);
      });
      consoleLog("preset: sleep / off-duty");
    }

    function setPresetActive(id) {
      ["preset-recognition", "preset-chaos", "preset-drift", "preset-cavity", "preset-sleep"].forEach((btnId) => {
        const btn = document.getElementById(btnId);
        btn.classList.remove("chip-btn-active");
      });
      if (id) {
        const b = document.getElementById(id);
        if (b) b.classList.add("chip-btn-active");
      }
    }

    // ========= STATE I/O =========
    function exportState() {
      const state = {
        L: HTM.L,
        seed: HTM.seed,
        eventActive: HTM.eventActive,
        cavityEnabled: HTM.cavityEnabled,
        cavityAmp: HTM.cavityAmp,
        eigen: {
          mu: HTM.eigen.mu,
          epsStable: HTM.eigen.epsStable,
          epsUnstable: HTM.eigen.epsUnstable
        },
        entropy: HTM.layers.map((l) => l.entropy)
      };
      const blob = new Blob([JSON.stringify(state, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "htm_cavity_state_ordis_v5.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      consoleLog("state exported to htm_cavity_state_ordis_v5.json");
    }

    function importState() {
      const text = prompt("Paste HTM state JSON here:");
      if (!text) return;
      try {
        const state = JSON.parse(text);
        if (!state || typeof state !== "object") throw new Error("bad json");
        if (typeof state.L === "number" && state.L >= 4 && state.L <= 64) {
          HTM.L = Math.floor(state.L);
        }
        if (typeof state.seed === "number") HTM.seed = state.seed;
        if (typeof state.eventActive === "boolean") HTM.eventActive = state.eventActive;
        if (typeof state.cavityEnabled === "boolean") HTM.cavityEnabled = state.cavityEnabled;
        if (typeof state.cavityAmp === "number") HTM.cavityAmp = state.cavityAmp;
        if (state.eigen) {
          if (typeof state.eigen.mu === "number") HTM.eigen.mu = state.eigen.mu;
          if (typeof state.eigen.epsStable === "number") HTM.eigen.epsStable = state.eigen.epsStable;
          if (typeof state.eigen.epsUnstable === "number") HTM.eigen.epsUnstable = state.eigen.epsUnstable;
        }
        setupLayers();
        if (Array.isArray(state.entropy)) {
          for (let l = 0; l < HTM.L && l < state.entropy.length; l++) {
            HTM.layers[l].entropy = Number(state.entropy[l]) || HTM.layers[l].entropy;
          }
        }
        consoleLog("state imported");
      } catch (err) {
        alert("Invalid JSON state.");
        consoleLog("failed to import state (invalid JSON)", "err");
      }
    }

    function randomizeSeeds() {
      HTM.seed = Math.random() * 10.0;
      HTM.layers.forEach((layer) => {
        layer.entropy = Math.random() * 2.5;
      });
    }

    function snapshotPNG() {
      try {
        const dataURL = renderer.domElement.toDataURL("image/png");
        const a = document.createElement("a");
        a.href = dataURL;
        a.download = "htm_cavity_screenshot_ordis_v5.png";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        consoleLog("snapshot saved as htm_cavity_screenshot_ordis_v5.png");
      } catch (e) {
        consoleLog("snapshot failed: " + e.message, "err");
      }
    }

    // ========= INIT & LOOP =========
    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 2000);
      // place the viewer inside the mirror skull, near its center
      const skullCenterY = (HTM.L - 1) * LAYER_SPACING * 0.5;
      camera.position.set(0, skullCenterY, SPHERE_RADIUS * 0.15);

      renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.rotateSpeed = 0.65;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.6;
      controls.screenSpacePanning = true;

      // orbit around the skull center so the viewer floats inside the cavity
      controls.target.set(0, skullCenterY, 0);
      controls.update();

      clock = new THREE.Clock();

      setupGlobalFrame();
      setupEigenHelices();
      setupMobius();
      setupLinks();
      setupLayers();
      setupMirrorSphere(); // new cavity

      const slider = document.getElementById("layer-slider");
      slider.addEventListener("input", (e) => {
        HTM.currentLayer = parseInt(e.target.value || "0", 10);
      });

      const timeSlider = document.getElementById("time-slider");
      timeSlider.addEventListener("input", (e) => {
        if (timeMode === "scrub") {
          const phase = parseFloat(e.target.value || "0");
          HTM.t = phase * 2 * Math.PI;
        }
      });

      document.getElementById("time-mode-btn").addEventListener("click", () => {
        timeMode = timeMode === "live" ? "scrub" : "live";
        if (timeMode === "scrub") {
          consoleSetStatus("scrub", "bg-fuchsia-900/60 text-fuchsia-300");
          document.getElementById("time-mode-btn").textContent = "scrub";
        } else {
          consoleSetStatus("live", "bg-sky-900/60 text-sky-300");
          document.getElementById("time-mode-btn").textContent = "live";
        }
      });

      document.getElementById("trigger-event").addEventListener("click", () => {
        HTM.eventActive = !HTM.eventActive;
        consoleLog(`attractor collapse ${HTM.eventActive ? "enabled" : "disabled"}`);
      });

      document.getElementById("toggle-cavity").addEventListener("click", () => {
        HTM.cavityEnabled = !HTM.cavityEnabled;
  
      // Track mouse for gravity probe
      document.addEventListener("pointermove", (event) => {
        const rect = renderer.domElement.getBoundingClientRect();
        const x = (event.clientX - rect.left) / rect.width;
        const y = (event.clientY - rect.top) / rect.height;
        mouse.x = x * 2 - 1;
        mouse.y = - (y * 2 - 1);
      });
      updateCavityButton();
        consoleLog(`cavity ${HTM.cavityEnabled ? "enabled" : "disabled"}`);
      });

      document.getElementById("preset-recognition").addEventListener("click", () => {
        applyPresetRecognition();
        setPresetActive("preset-recognition");
      });
      document.getElementById("preset-chaos").addEventListener("click", () => {
        applyPresetChaos();
        setPresetActive("preset-chaos");
      });
      document.getElementById("preset-drift").addEventListener("click", () => {
        applyPresetDrift();
        setPresetActive("preset-drift");
      });
      document.getElementById("preset-cavity").addEventListener("click", () => {
        applyPresetCavity();
        setPresetActive("preset-cavity");
      });
      document.getElementById("preset-sleep").addEventListener("click", () => {
        applyPresetSleep();
        setPresetActive("preset-sleep");
      });

      document.getElementById("btn-export").addEventListener("click", exportState);
      document.getElementById("btn-import").addEventListener("click", importState);
      document.getElementById("btn-randomize").addEventListener("click", () => {
        randomizeSeeds();
        setPresetActive("");
        consoleLog("randomized entropy and seed");
      });
      document.getElementById("btn-freeze").addEventListener("click", () => {
        paused = !paused;
        if (paused) {
          consoleSetStatus("paused", "bg-slate-900/60 text-slate-300");
          consoleLog("simulation paused");
        } else {
          consoleSetStatus("live", "bg-sky-900/60 text-sky-300");
          consoleLog("simulation resumed");
        }
      });
      document.getElementById("btn-snapshot").addEventListener("click", snapshotPNG);

            const hudPanel = document.getElementById("hud-panel");
      const hudMenuToggle = document.getElementById("hud-menu-toggle");
      const hudSectionBar = document.getElementById("hud-section-toggles");
      let hudMenuOpen = false;
      if (hudMenuToggle && hudSectionBar && hudPanel) {
        // initial state: everything collapsed
        hudPanel.style.display = "none";
        hudSectionBar.style.display = "none";
        hudMenuToggle.textContent = "HUD Menu ▸";

        const hudSectionToggles = document.querySelectorAll(".hud-section-toggle");
        hudSectionToggles.forEach((btn) => {
          const targetId = btn.dataset.target;
          const card = document.getElementById(targetId);
          if (!card) return;
          // start with all cards hidden and toggles inactive
          card.style.display = "none";
          btn.classList.remove("chip-btn-active");
          btn.addEventListener("click", () => {
            const isHidden = card.style.display === "none";
            card.style.display = isHidden ? "block" : "none";
            btn.classList.toggle("chip-btn-active", isHidden);
          });
        });

        hudMenuToggle.addEventListener("click", () => {
          hudMenuOpen = !hudMenuOpen;
          const display = hudMenuOpen ? "block" : "none";
          hudPanel.style.display = display;
          hudSectionBar.style.display = hudMenuOpen ? "flex" : "none";
          hudMenuToggle.textContent = hudMenuOpen ? "HUD Menu ▾" : "HUD Menu ▸";
        });
      }

      const radioBtn = document.getElementById("btn-radio-toggle");
      const radioStatus = document.getElementById("radio-status-label");
      if (radioStatus) {
        CavityRadio.statusElement = radioStatus;
        radioStatus.textContent = "silent";
      }
      if (radioBtn) {
        radioBtn.addEventListener("click", () => {
          const next = !CavityRadio.enabled;
          CavityRadio.setEnabled(next);
          radioBtn.textContent = next ? "Radio: on" : "Radio: off";
          if (!next && radioStatus) {
            radioStatus.textContent = "silent";
          }
        });
      }

      const consoleBtn = document.getElementById("toggle-console-btn");
      const consolePanel = document.getElementById("console-panel");
      let consoleHidden = true;
      if (consolePanel && consoleBtn) {
        // initial: console hidden
        consolePanel.style.display = "none";
        consoleBtn.textContent = "Show Console";
        consoleBtn.addEventListener("click", () => {
          consoleHidden = !consoleHidden;
          consolePanel.style.display = consoleHidden ? "none" : "block";
          consoleBtn.textContent = consoleHidden ? "Show Console" : "Hide Console";
        });
      }

      const consoleInput = document.getElementById("console-input");
      const consoleSend = document.getElementById("console-send");
      const consoleClear = document.getElementById("console-clear");
      consoleSend.addEventListener("click", () => {
        handleConsoleCommand(consoleInput.value);
        consoleInput.value = "";
      });
      consoleInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          handleConsoleCommand(consoleInput.value);
          consoleInput.value = "";
        }
      });
      consoleClear.addEventListener("click", () => {
        document.getElementById("console-log").innerHTML = "";
      });

      window.addEventListener("resize", onResize);

      applyPresetRecognition();
      setPresetActive("preset-recognition");
      updateCavityButton();
      consoleLog("HTM Cavity Lab v5 + Mirror Sphere ready — type 'help' in the console");
      initMoE();
      animate();
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    

// === Ordis MoE / GRU Micro-Experts (v3) ===============================
// This block replaces the earlier toy MoE with a slightly more honest
// recurrent micro–MoE. Each expert is a tiny GRU cell with its own
// hidden state and random readout heads. A softmax router chooses which
// experts update on each frame based on HTM + mirror–sphere state.
// The whole thing is *still* tiny and light enough for mobile, but the
// dynamics are now genuinely recurrent, gated, and weakly plastic.

// ---- small linear algebra helpers ----
function randVec(n) {
  const v = new Array(n);
  for (let i = 0; i < n; i++) v[i] = (Math.random() - 0.5) * 0.6;
  return v;
}
function randMat(rows, cols) {
  const M = new Array(rows);
  for (let i = 0; i < rows; i++) {
    const row = new Array(cols);
    for (let j = 0; j < cols; j++) row[j] = (Math.random() - 0.5) * 0.35;
    M[i] = row;
  }
  return M;
}
function zeros(n) {
  const v = new Array(n);
  for (let i = 0; i < n; i++) v[i] = 0.0;
  return v;
}
function dotVec(a, b) {
  let s = 0.0;
  const n = Math.min(a.length, b.length);
  for (let i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}
function addVec(a, b) {
  const n = Math.min(a.length, b.length);
  const out = new Array(n);
  for (let i = 0; i < n; i++) out[i] = a[i] + b[i];
  return out;
}
function hadamard(a, b) {
  const n = Math.min(a.length, b.length);
  const out = new Array(n);
  for (let i = 0; i < n; i++) out[i] = a[i] * b[i];
  return out;
}
function subScalarFromVec(s, a) {
  const out = new Array(a.length);
  for (let i = 0; i < a.length; i++) out[i] = s - a[i];
  return out;
}
function mulMatVec(M, v) {
  const out = new Array(M.length);
  for (let i = 0; i < M.length; i++) {
    out[i] = dotVec(M[i], v);
  }
  return out;
}
function sigmoid(z) {
  return 1.0 / (1.0 + Math.exp(-z));
}
function softmax(arr) {
  let max = -Infinity;
  for (let i = 0; i < arr.length; i++) if (arr[i] > max) max = arr[i];
  const exps = new Array(arr.length);
  let sum = 0.0;
  for (let i = 0; i < arr.length; i++) {
    const e = Math.exp(arr[i] - max);
    exps[i] = e;
    sum += e;
  }
  const out = new Array(arr.length);
  if (sum <= 0) {
    const frac = 1.0 / arr.length;
    for (let i = 0; i < arr.length; i++) out[i] = frac;
    return out;
  }
  for (let i = 0; i < arr.length; i++) out[i] = exps[i] / sum;
  return out;
}

// ---- tiny GRU expert ----
function TinyGRUExpert(kind, name, inputDim, hiddenDim) {
  this.kind = kind;         // "affect" or "reasoning"
  this.name = name;
  this.inputDim = inputDim;
  this.hiddenDim = hiddenDim;
  this.h = zeros(hiddenDim);
  this.age = 0.0;

  this.Wz = randMat(hiddenDim, inputDim);
  this.Uz = randMat(hiddenDim, hiddenDim);
  this.bz = randVec(hiddenDim);

  this.Wr = randMat(hiddenDim, inputDim);
  this.Ur = randMat(hiddenDim, hiddenDim);
  this.br = randVec(hiddenDim);

  this.Wh = randMat(hiddenDim, inputDim);
  this.Uh = randMat(hiddenDim, hiddenDim);
  this.bh = randVec(hiddenDim);

  // light readout heads
  this.headValence = randVec(hiddenDim);
  this.headActivation = randVec(hiddenDim);
  this.headCoherence = randVec(hiddenDim);
}

TinyGRUExpert.prototype.step = function(x, dt) {
  // z = σ(Wz x + Uz h + bz)
  const Wz_x = mulMatVec(this.Wz, x);
  const Uz_h = mulMatVec(this.Uz, this.h);
  const Wr_x = mulMatVec(this.Wr, x);
  const Ur_h = mulMatVec(this.Ur, this.h);
  const Wh_x = mulMatVec(this.Wh, x);
  const Uh_h = mulMatVec(this.Uh, this.h);

  const z = new Array(this.hiddenDim);
  const r = new Array(this.hiddenDim);
  const hTilde = new Array(this.hiddenDim);
  const hNew = new Array(this.hiddenDim);

  for (let i = 0; i < this.hiddenDim; i++) {
    const z_i = sigmoid(Wz_x[i] + Uz_h[i] + this.bz[i]);
    const r_i = sigmoid(Wr_x[i] + Ur_h[i] + this.br[i]);
    const hHat_i = Math.tanh(Wh_x[i] + r_i * Uh_h[i] + this.bh[i]);
    const h_i = this.h[i];
    const hNew_i = (1 - z_i) * h_i + z_i * hHat_i;
    z[i] = z_i;
    r[i] = r_i;
    hTilde[i] = hHat_i;
    hNew[i] = hNew_i;
  }

  this.h = hNew;
  this.age += dt;

  // simple heads
  const valence = Math.tanh(dotVec(this.headValence, this.h));
  const activation = sigmoid(dotVec(this.headActivation, this.h));
  const coherence = sigmoid(dotVec(this.headCoherence, this.h));

  return { valence, activation, coherence };
};

// light Hebbian-ish update on Wh
TinyGRUExpert.prototype.hebbianUpdate = function(x, lr) {
  const L = lr || 0.0008;
  for (let i = 0; i < this.Wh.length; i++) {
    const h_i = this.h[i];
    if (Math.abs(h_i) < 1e-3) continue;
    const row = this.Wh[i];
    for (let j = 0; j < row.length; j++) {
      row[j] += L * h_i * x[j];
    }
  }
};

// ---- router ----
function MoERouter(numExperts, keyDim) {
  this.keyDim = keyDim;
  this.keys = [];
  for (let i = 0; i < numExperts; i++) {
    this.keys.push(randVec(keyDim));
  }
}
MoERouter.prototype.route = function(x) {
  const scores = new Array(this.keys.length);
  for (let i = 0; i < this.keys.length; i++) {
    scores[i] = dotVec(this.keys[i], x);
  }
  const gates = softmax(scores);
  // store last routing weights for synaptic visualization & gravity coupling
  this.lastGates = gates.slice();
  return gates;
};

// ---- global MoE state ----
const MoE = {
  experts: [],
  router: null,
  inputDim: 8,
  hiddenDim: 4,
  maxExperts: 16,
  baseExperts: 8,
  lastSpawnTime: 0,
  // per-expert synaptic flux (updated each frame from router + heads)
  synapticFlux: [],
  metrics: {
    affect: 0.0,
    reasoning: 0.0,
    interactions: 0.0,
    regime: "idle",
    synapticMass: 0.0
  }
};

// build input vector from HTM + mirror sphere state
function buildMoEInputVector(time, normInteraction) {
  let normLayer = 0.0;
  let entropy = 0.0;
  let deltaH = 0.0;

  try {
    const L = HTM.L || (HTM.layers ? HTM.layers.length : 1);
    const c = HTM.currentLayer || 0;
    normLayer = L > 1 ? c / (L - 1) : 0.0;
    if (HTM.layers && HTM.layers[c]) {
      entropy = HTM.layers[c].entropy || 0.0;
    }
    deltaH = HTM.recognitionDelta || 0.0;
  } catch (_) {
    // leave defaults
  }

  const cavity = HTM.cavityEnabled ? HTM.cavityAmp : 0.0;
  const eNorm = Math.tanh(entropy / 4.0);
  const dNorm = THREE.MathUtils.clamp(deltaH / 2.0, -1.0, 1.0);
  const iNorm = THREE.MathUtils.clamp(normInteraction, 0.0, 1.0);
  const phase = Math.sin(time * 0.35 + HTM.seed);

  // Local gravity probe coupling (weak-field, dimensionless)
  let phiNorm = 0.0;
  let curvNorm = 0.0;
  try {
    if (gravityProbe && typeof gravityProbe.phi === "number") {
      // rescale potential; typical |phi| << 1
      phiNorm = THREE.MathUtils.clamp(gravityProbe.phi * 4.0, -1.0, 1.0);
    }
    if (gravityProbe && typeof gravityProbe.curv === "number") {
      curvNorm = THREE.MathUtils.clamp(gravityProbe.curv * 0.5, -1.0, 1.0);
    }
  } catch (_) {
    // leave defaults
  }

  return [normLayer, eNorm, dNorm, cavity, iNorm, phase, phiNorm, curvNorm];
}

function initMoE() {
  if (typeof window === "undefined") return;
  if (!window.HTM) window.HTM = {};
  if (!HTM.hud) HTM.hud = {};

  MoE.experts = [];
  const kinds = [
    { kind: "affect", name: "valence" },
    { kind: "affect", name: "arousal" },
    { kind: "reasoning", name: "coherence" },
    { kind: "reasoning", name: "stability" },
    { kind: "affect", name: "tone" },
    { kind: "reasoning", name: "clarity" },
    { kind: "affect", name: "salience" },
    { kind: "reasoning", name: "focus" }
  ];
  kinds.forEach((cfg) => {
    MoE.experts.push(
      new TinyGRUExpert(cfg.kind, cfg.name, MoE.inputDim, MoE.hiddenDim)
    );
  });
  MoE.router = new MoERouter(MoE.maxExperts, MoE.inputDim);

  // HUD wiring (non-invasive: appended to existing hud-root)
  try {
    const hudRoot = document.getElementById("hud-root");
    if (hudRoot) {
      const label = document.createElement("p");
      label.id = "moe-affect-label";
      label.className = "mono text-[10px] text-cyan-300 mt-1";
      label.textContent = "Affect: 0.00 · Reasoning: 0.00";
      hudRoot.appendChild(label);
      HTM.hud.affectLabel = label;

      const expertsLine = document.createElement("p");
      expertsLine.id = "moe-experts-label";
      expertsLine.className = "mono text-[10px] text-sky-200";
      expertsLine.textContent = "Experts: 0 · affect gate mass: 0.00 · reasoning gate mass: 0.00";
      hudRoot.appendChild(expertsLine);
      HTM.hud.expertsLabel = expertsLine;

      const regimeLine = document.createElement("p");
      regimeLine.id = "moe-regime-label";
      regimeLine.className = "mono text-[10px] text-indigo-200";
      regimeLine.textContent = "Ensemble regime: idle";
      hudRoot.appendChild(regimeLine);
      HTM.hud.regimeLabel = regimeLine;
    }
  } catch (e) {
    console.warn("MoE HUD init failed", e);
  }
}

// One MoE update step driven by approximate photon–crystal interaction density.
function updateMoE(time, dt) {
  if (!sim || !sim.mirrorSphere || !MoE.router || !MoE.experts.length) return;
  const ms = sim.mirrorSphere;
  const photons = ms.photonPositions ? ms.photonPositions.array : null;
  const crystals = ms.crystals || [];
  if (!photons || crystals.length === 0) return;

  let interactionCount = 0;
  let hitThisFrame = false;
  const stride = 15;

  for (let i = 0; i < ms.numPhotons; i += stride) {
    const px = photons[3 * i];
    const py = photons[3 * i + 1];
    const pz = photons[3 * i + 2];
    for (let k = 0; k < crystals.length; k++) {
      const c = crystals[k];
      const dx = px - c.position.x;
      const dy = py - c.position.y;
      const dz = pz - c.position.z;
      const r = c.scale.x * 2.2;
      if (dx * dx + dy * dy + dz * dz < r * r) {
        interactionCount++;
        hitThisFrame = true;
        break;
      }
    }
  }

  const maxInteractions = (ms.numPhotons / stride) * crystals.length + 1e-6;
  const normInteraction = THREE.MathUtils.clamp(
    interactionCount / maxInteractions,
    0.0,
    1.0
  );
  MoE.metrics.interactions = normInteraction;

  const x = buildMoEInputVector(time, normInteraction);
  const gates = MoE.router.route(x);

  let affectMix = 0.0;
  let reasoningMix = 0.0;
  let gateMassA = 0.0;
  let gateMassR = 0.0;
  let activeCount = 0;
  const maxAge = 120.0;

  const lrBase = hitThisFrame ? 0.0012 : 0.0;

  MoE.experts.forEach((exp, idx) => {
    const gate = gates[idx % gates.length];
    if (gate < 0.03) {
      exp.age += dt;
      return;
    }
    activeCount++;

    const heads = exp.step(x, dt);
    if (exp.kind === "affect") {
      affectMix += gate * heads.valence;
      gateMassA += gate;
    } else {
      reasoningMix += gate * heads.coherence;
      gateMassR += gate;
    }

    // per-expert synaptic flux: gated magnitude of the expert's head output
    const headMag = Math.sqrt(
      heads.valence * heads.valence + heads.coherence * heads.coherence + 1e-8
    );
    if (!Array.isArray(MoE.synapticFlux) || MoE.synapticFlux.length !== MoE.experts.length) {
      MoE.synapticFlux = new Array(MoE.experts.length).fill(0.0);
    }
    const signedFlux = gate * headMag * (exp.kind === "affect" ? Math.sign(heads.valence || 0.0) : Math.sign(heads.coherence || 0.0));
    // exponential moving average to keep streams smooth
    const alpha = 0.32;
    const prev = MoE.synapticFlux[idx] || 0.0;
    MoE.synapticFlux[idx] = (1.0 - alpha) * prev + alpha * signedFlux;

    if (lrBase > 0) {
      exp.hebbianUpdate(x, lrBase * gate);
    }
  });

  if (gateMassA > 0) affectMix /= gateMassA;
  if (gateMassR > 0) reasoningMix /= gateMassR;

  // spawn & prune: experts that are active, coherent, and in high-interaction regimes
  const now = time;
  if (
    activeCount > 0 &&
    MoE.experts.length < MoE.maxExperts &&
    now - MoE.lastSpawnTime > 3.5 &&
    reasoningMix > 0.55 &&
    normInteraction > 0.4
  ) {
    const parent = MoE.experts[Math.floor(Math.random() * MoE.experts.length)];
    const child = new TinyGRUExpert(
      parent.kind,
      parent.name + "_child",
      MoE.inputDim,
      MoE.hiddenDim
    );
    // seed child near parent state
    for (let i = 0; i < child.h.length && i < parent.h.length; i++) {
      child.h[i] = parent.h[i] * 0.6;
    }
    MoE.experts.push(child);
    MoE.lastSpawnTime = now;
  }

  MoE.experts = MoE.experts.filter((exp) => {
    if (MoE.experts.length <= MoE.baseExperts) return true;
    const mag = Math.sqrt(dotVec(exp.h, exp.h));
    return !(exp.age > maxAge && mag < 0.08);
  });

  MoE.metrics.affect = affectMix;
  MoE.metrics.reasoning = reasoningMix;

  // aggregate synaptic mass as the L1 norm of per-expert flux
  if (Array.isArray(MoE.synapticFlux) && MoE.synapticFlux.length > 0) {
    let mass = 0.0;
    for (let i = 0; i < MoE.synapticFlux.length; i++) {
      mass += Math.abs(MoE.synapticFlux[i]);
    }
    MoE.metrics.synapticMass = mass;
  } else {
    MoE.metrics.synapticMass = 0.0;
  }

  let regime = "idle";
  if (affectMix > 0.6 && reasoningMix > 0.6) regime = "focused";
  else if (affectMix < -0.3 && reasoningMix < 0.4) regime = "suppressed";
  else if (normInteraction > 0.6) regime = "rich-interaction";
  MoE.metrics.regime = regime;

  if (window.HTM && HTM.hud && HTM.hud.affectLabel) {
    HTM.hud.affectLabel.textContent =
      "Affect: " +
      affectMix.toFixed(2) +
      " · Reasoning: " +
      reasoningMix.toFixed(2);

    if (HTM.hud.expertsLabel) {
      HTM.hud.expertsLabel.textContent =
        "Experts: " +
        MoE.experts.length +
        " · affect gate mass: " +
        gateMassA.toFixed(2) +
        " · reasoning gate mass: " +
        gateMassR.toFixed(2) +
        " · interactions: " +
        normInteraction.toFixed(2) +
        " · synaptic mass: " +
        (MoE.metrics.synapticMass || 0.0).toFixed(2);
    }

    if (HTM.hud.regimeLabel) {
      HTM.hud.regimeLabel.textContent = "Ensemble regime: " + regime;
    }
  }
}


function animate() {
      requestAnimationFrame(animate);
      const elapsed = (clock && clock.getElapsedTime()) || 0;
      const dt = elapsed - lastFrameTime;
      lastFrameTime = elapsed;

      if (!paused) {
        if (timeMode === "live") {
          HTM.t += dt * 1.0;
        }
      }

      const time = HTM.t;

      updateEntropy(time, dt);
      updateGlobalFrame(time);
      updateGravityHeatmap();
      updateGravityProbe(time);
      CavityRadio.update(dt);
      updateEigenHelices(time, dt);
      updateSynapseStreams(time);
      updateSynapseNetwork(time);
      updateSynapseDownlinks(time);
      updateMobius(time);
      updateLinks(time);
      updateLayers(time);
      updateMirrorSphere(time, dt);
      updateMoE(time, dt);
      OrdisWill.step(dt);
      syncUI();

      controls.update();
      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>
